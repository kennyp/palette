
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>colorbook: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kennyp/palette/adobe/colorbook/bookid_string.go (0.0%)</option>
				
				<option value="file1">github.com/kennyp/palette/adobe/colorbook/colorbook.go (0.0%)</option>
				
				<option value="file2">github.com/kennyp/palette/adobe/colorbook/colortype_string.go (0.0%)</option>
				
				<option value="file3">github.com/kennyp/palette/adobe/colorswatch/colorspace_string.go (0.0%)</option>
				
				<option value="file4">github.com/kennyp/palette/adobe/colorswatch/colorswatch.go (0.0%)</option>
				
				<option value="file5">github.com/kennyp/palette/adobe/types/string.go (0.0%)</option>
				
				<option value="file6">github.com/kennyp/palette/color/color.go (88.8%)</option>
				
				<option value="file7">github.com/kennyp/palette/init.go (100.0%)</option>
				
				<option value="file8">github.com/kennyp/palette/io/colorbook/colorbook.go (0.0%)</option>
				
				<option value="file9">github.com/kennyp/palette/io/colorswatch/colorswatch.go (0.0%)</option>
				
				<option value="file10">github.com/kennyp/palette/io/csv/csv.go (73.6%)</option>
				
				<option value="file11">github.com/kennyp/palette/io/io.go (96.2%)</option>
				
				<option value="file12">github.com/kennyp/palette/io/json/json.go (89.1%)</option>
				
				<option value="file13">github.com/kennyp/palette/palette/palette.go (91.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by "stringer -type=BookID -trimprefix=BookID"; DO NOT EDIT.

package colorbook

import "strconv"

func _() {
        // An "invalid array index" compiler error signifies that the constant values have changed.
        // Re-run the stringer command to generate them again.
        var x [1]struct{}
        _ = x[BookIDANPA-3000]
        _ = x[BookIDFocoltone-3001]
        _ = x[BookIDPantoneCoated-3002]
        _ = x[BookIDPantoneProcess-3003]
        _ = x[BookIDPantoneProSlim-3004]
        _ = x[BookIDPantoneUncoated-3005]
        _ = x[BookIDToyo-3006]
        _ = x[BookIDTrumatch-3007]
        _ = x[BookIDHKSE-3008]
        _ = x[BookIDHKSK-3009]
        _ = x[BookIDHKSN-3010]
        _ = x[BookIDHKSZ-3011]
        _ = x[BookIDDIC-3012]
        _ = x[BookIDPantonePastelCoated-3020]
        _ = x[BookIDPantonePastelUncoated-3021]
        _ = x[BookIDPantoneMetallic-3022]
}

const (
        _BookID_name_0 = "ANPAFocoltonePantoneCoatedPantoneProcessPantoneProSlimPantoneUncoatedToyoTrumatchHKSEHKSKHKSNHKSZDIC"
        _BookID_name_1 = "PantonePastelCoatedPantonePastelUncoatedPantoneMetallic"
)

var (
        _BookID_index_0 = [...]uint8{0, 4, 13, 26, 40, 54, 69, 73, 81, 85, 89, 93, 97, 100}
        _BookID_index_1 = [...]uint8{0, 19, 40, 55}
)

func (i BookID) String() string <span class="cov0" title="0">{
        switch </span>{
        case 3000 &lt;= i &amp;&amp; i &lt;= 3012:<span class="cov0" title="0">
                i -= 3000
                return _BookID_name_0[_BookID_index_0[i]:_BookID_index_0[i+1]]</span>
        case 3020 &lt;= i &amp;&amp; i &lt;= 3022:<span class="cov0" title="0">
                i -= 3020
                return _BookID_name_1[_BookID_index_1[i]:_BookID_index_1[i+1]]</span>
        default:<span class="cov0" title="0">
                return "BookID(" + strconv.FormatInt(int64(i), 10) + ")"</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package colorbook provides types for reading and writing Adobe Color Book files.
//
// Spec is implemented per the [documentation].
//
// [documentation]: https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/#50577411_pgfId-1066780
package colorbook

import (
        "bytes"
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "log/slog"
        "unicode/utf16"
        "unicode/utf8"
)

const (
        FileType              = "8BCB" // Signature and filetype for a Color Book file.
        DefaultVersion uint16 = 1      // Default ersion of Adobe Color Book format.
)

//go:generate go tool stringer -type=BookID -trimprefix=BookID
type BookID uint16 // Unique ID for a ColorBook

const (
        BookIDANPA                  BookID = 3000
        BookIDFocoltone             BookID = 3001
        BookIDPantoneCoated         BookID = 3002
        BookIDPantoneProcess        BookID = 3003
        BookIDPantoneProSlim        BookID = 3004
        BookIDPantoneUncoated       BookID = 3005
        BookIDToyo                  BookID = 3006
        BookIDTrumatch              BookID = 3007
        BookIDHKSE                  BookID = 3008
        BookIDHKSK                  BookID = 3009
        BookIDHKSN                  BookID = 3010
        BookIDHKSZ                  BookID = 3011
        BookIDDIC                   BookID = 3012
        BookIDPantonePastelCoated   BookID = 3020
        BookIDPantonePastelUncoated BookID = 3021
        BookIDPantoneMetallic       BookID = 3022
)

//go:generate go tool stringer -type=ColorType -trimprefix=ColorType
type ColorType uint16

const (
        ColorTypeRGB  ColorType = 0
        ColorTypeCMYK ColorType = 2
        ColorTypeLab  ColorType = 7
)

type Color struct {
        Name       string  `json:"name"`
        Key        [6]byte `json:"key"`
        Components [3]byte `json:"components"`
}

type ColorBook struct {
        ID            BookID    `json:"book_id"`
        Version       uint16    `json:"version"`
        Title         string    `json:"title"`
        Description   string    `json:"description"`
        Prefix        string    `json:"prefix"`
        Postfix       string    `json:"postfix"`
        ColorsPerPage uint16    `json:"colors_per_page"`
        KeyColorPage  uint16    `json:"key_color_page"`
        ColorType     ColorType `json:"color_type"`
        Colors        []*Color  `json:"colors"`
}

func (b *ColorBook) MarshalBinary() ([]byte, error) <span class="cov0" title="0">{
        return nil, errors.New("not implemented")
}</span>

func (b *ColorBook) UnmarshalBinary(data []byte) (err error) <span class="cov0" title="0">{
        buf := bytes.NewReader(data)

        signature := make([]byte, 4)
        if _, err := io.ReadFull(buf, signature); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">slog.Debug("verifying signature", slog.String("signature", string(signature)))
        if FileType != string(signature) </span><span class="cov0" title="0">{
                return errors.New("invalid file type")
        }</span>

        <span class="cov0" title="0">if err := binary.Read(buf, binary.BigEndian, &amp;b.Version); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">slog.Debug("verifying version", slog.Int("version", int(b.Version)))
        if b.Version != DefaultVersion </span><span class="cov0" title="0">{
                return fmt.Errorf("version %d not supported", b.Version)
        }</span>

        <span class="cov0" title="0">if err := binary.Read(buf, binary.BigEndian, &amp;b.ID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse book id (%w)", err)
        }</span>

        <span class="cov0" title="0">if b.Title, err = readString(slog.With("field", "Title"), buf); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if b.Prefix, err = readString(slog.With("field", "prefix"), buf); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if b.Postfix, err = readString(slog.With("field", "postfix"), buf); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if b.Description, err = readString(slog.With("field", "description"), buf); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var numColors uint16
        if err := binary.Read(buf, binary.BigEndian, &amp;numColors); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse number of colors (%w)", err)
        }</span>

        <span class="cov0" title="0">if err := binary.Read(buf, binary.BigEndian, &amp;b.ColorsPerPage); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse colors per page (%w)", err)
        }</span>

        <span class="cov0" title="0">if err := binary.Read(buf, binary.BigEndian, &amp;b.KeyColorPage); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse key color page (%w)", err)
        }</span>

        <span class="cov0" title="0">if err := binary.Read(buf, binary.BigEndian, &amp;b.ColorType); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse color type (%w)", err)
        }</span>

        <span class="cov0" title="0">if !(b.ColorType == ColorTypeRGB || b.ColorType != ColorTypeCMYK || b.ColorType == ColorTypeLab) </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected color type %v", b.ColorType)
        }</span>

        <span class="cov0" title="0">b.Colors = make([]*Color, numColors)
        for i := range b.Colors </span><span class="cov0" title="0">{
                c := &amp;Color{}

                if c.Name, err = readString(slog.With("color", i, "field", "name"), buf); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if _, err := io.ReadFull(buf, c.Key[:]); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read key for color %d (%w)", i, err)
                }</span>

                <span class="cov0" title="0">if err := binary.Read(buf, binary.BigEndian, &amp;c.Components); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read components for color %d (%w)", i, err)
                }</span>

                <span class="cov0" title="0">slog.Debug("parsed color", slog.Int("index", i), slog.Any("color", c))

                b.Colors[i] = c</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func readString(log *slog.Logger, r io.Reader) (string, error) <span class="cov0" title="0">{
        var length uint32

        if err := binary.Read(r, binary.BigEndian, &amp;length); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read length (%w)", err)
        }</span>

        <span class="cov0" title="0">log.Debug("read length", slog.Any("length", length))

        s := make([]byte, 2*length)
        if _, err := io.ReadFull(r, s); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read bytes (%w)", err)
        }</span>

        <span class="cov0" title="0">ret := &amp;bytes.Buffer{}

        u16s := make([]uint16, 1)
        b8s := make([]byte, 4)
        for i, l := 0, len(s); i &lt; l; i += 2 </span><span class="cov0" title="0">{
                u16s[0] = uint16(s[i+1]) + (uint16(s[i]) &lt;&lt; 8)
                r := utf16.Decode(u16s)
                n := utf8.EncodeRune(b8s, r[0])
                if _, err := ret.Write(b8s[:n]); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to write rune %d (%w)", i, err)
                }</span>
        }

        <span class="cov0" title="0">return ret.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by "stringer -type=ColorType -trimprefix=ColorType"; DO NOT EDIT.

package colorbook

import "strconv"

func _() {
        // An "invalid array index" compiler error signifies that the constant values have changed.
        // Re-run the stringer command to generate them again.
        var x [1]struct{}
        _ = x[ColorTypeRGB-0]
        _ = x[ColorTypeCMYK-2]
        _ = x[ColorTypeLab-7]
}

const (
        _ColorType_name_0 = "RGB"
        _ColorType_name_1 = "CMYK"
        _ColorType_name_2 = "Lab"
)

func (i ColorType) String() string <span class="cov0" title="0">{
        switch </span>{
        case i == 0:<span class="cov0" title="0">
                return _ColorType_name_0</span>
        case i == 2:<span class="cov0" title="0">
                return _ColorType_name_1</span>
        case i == 7:<span class="cov0" title="0">
                return _ColorType_name_2</span>
        default:<span class="cov0" title="0">
                return "ColorType(" + strconv.FormatInt(int64(i), 10) + ")"</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by "stringer -type=ColorSpace -trimprefix=ColorSpace"; DO NOT EDIT.

package colorswatch

import "strconv"

func _() {
        // An "invalid array index" compiler error signifies that the constant values have changed.
        // Re-run the stringer command to generate them again.
        var x [1]struct{}
        _ = x[ColorSpaceRGB-0]
        _ = x[ColorSpaceHSB-1]
        _ = x[ColorSpaceCMYK-2]
        _ = x[ColorSpaceLab-7]
        _ = x[ColorSpaceGrayscale-8]
        _ = x[ColorSpacePantone-3]
        _ = x[ColorSpaceFocoltone-4]
        _ = x[ColorSpaceTruematch-5]
        _ = x[ColorSpaceToyo-6]
        _ = x[ColorSpaceHKS-10]
}

const (
        _ColorSpace_name_0 = "RGBHSBCMYKPantoneFocoltoneTruematchToyoLabGrayscale"
        _ColorSpace_name_1 = "HKS"
)

var (
        _ColorSpace_index_0 = [...]uint8{0, 3, 6, 10, 17, 26, 35, 39, 42, 51}
)

func (i ColorSpace) String() string <span class="cov0" title="0">{
        switch </span>{
        case i &lt;= 8:<span class="cov0" title="0">
                return _ColorSpace_name_0[_ColorSpace_index_0[i]:_ColorSpace_index_0[i+1]]</span>
        case i == 10:<span class="cov0" title="0">
                return _ColorSpace_name_1</span>
        default:<span class="cov0" title="0">
                return "ColorSpace(" + strconv.FormatInt(int64(i), 10) + ")"</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package colorswatch provides types for reading and writing Adobe Color Swatch files.
//
// Implements Adobe Color Swatch (.aco) format specification.
package colorswatch

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "io"
        "log/slog"
        "unicode/utf16"
        "unicode/utf8"
)

const (
        FileTypeMac     = "8BCO" // Signature and filetype for a Mac Color Swatch file
        FileTypeWindows = "ACO"  // Extension for a Windows Color Swatch file
        Version1        = 1      // Version 1 format (no color names)
        Version2        = 2      // Version 2 format (with color names)
)

//go:generate go tool stringer -type=ColorSpace -trimprefix=ColorSpace
type ColorSpace uint16

const (
        ColorSpaceRGB       ColorSpace = 0
        ColorSpaceHSB       ColorSpace = 1
        ColorSpaceCMYK      ColorSpace = 2
        ColorSpaceLab       ColorSpace = 7
        ColorSpaceGrayscale ColorSpace = 8
        ColorSpacePantone   ColorSpace = 3
        ColorSpaceFocoltone ColorSpace = 4
        ColorSpaceTruematch ColorSpace = 5
        ColorSpaceToyo      ColorSpace = 6
        ColorSpaceHKS       ColorSpace = 10
)

type ColorSwatch struct {
        Version uint16   `json:"version"`
        Colors  []*Color `json:"colors"`
}

type Color struct {
        ColorSpace ColorSpace `json:"color_space"`
        Values     [4]uint16  `json:"values"`
        Name       string     `json:"name"`
}

func (cs *ColorSwatch) MarshalBinary() ([]byte, error) <span class="cov0" title="0">{
        buf := &amp;bytes.Buffer{}

        // Write version
        if err := binary.Write(buf, binary.BigEndian, cs.Version); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write version: %w", err)
        }</span>

        // Write number of colors
        <span class="cov0" title="0">numColors := uint16(len(cs.Colors))
        if err := binary.Write(buf, binary.BigEndian, numColors); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write number of colors: %w", err)
        }</span>

        // Write colors (version 1 data)
        <span class="cov0" title="0">for i, color := range cs.Colors </span><span class="cov0" title="0">{
                if err := binary.Write(buf, binary.BigEndian, color.ColorSpace); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write color space for color %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">if err := binary.Write(buf, binary.BigEndian, color.Values); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write values for color %d: %w", i, err)
                }</span>
        }

        // If version 2, write color names
        <span class="cov0" title="0">if cs.Version == Version2 </span><span class="cov0" title="0">{
                // Write version again
                if err := binary.Write(buf, binary.BigEndian, cs.Version); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write version 2 header: %w", err)
                }</span>

                // Write number of colors again
                <span class="cov0" title="0">if err := binary.Write(buf, binary.BigEndian, numColors); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write version 2 color count: %w", err)
                }</span>

                // Write colors with names
                <span class="cov0" title="0">for i, color := range cs.Colors </span><span class="cov0" title="0">{
                        if err := binary.Write(buf, binary.BigEndian, color.ColorSpace); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to write v2 color space for color %d: %w", i, err)
                        }</span>

                        <span class="cov0" title="0">if err := binary.Write(buf, binary.BigEndian, color.Values); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to write v2 values for color %d: %w", i, err)
                        }</span>

                        <span class="cov0" title="0">if err := writeString(buf, color.Name); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to write name for color %d: %w", i, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

func writeString(w io.Writer, s string) error <span class="cov0" title="0">{
        runes := []rune(s)
        length := uint32(len(runes) + 1) // +1 for null terminator

        // Write length
        if err := binary.Write(w, binary.BigEndian, length); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write string length: %w", err)
        }</span>

        // Encode to UTF-16 and write
        <span class="cov0" title="0">encoded := utf16.Encode(runes)
        for _, u16 := range encoded </span><span class="cov0" title="0">{
                if err := binary.Write(w, binary.BigEndian, u16); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write UTF-16 character: %w", err)
                }</span>
        }

        // Write null terminator
        <span class="cov0" title="0">if err := binary.Write(w, binary.BigEndian, uint16(0)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write null terminator: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (cs *ColorSwatch) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        buf := bytes.NewReader(data)

        // Read version
        if err := binary.Read(buf, binary.BigEndian, &amp;cs.Version); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read version: %w", err)
        }</span>

        <span class="cov0" title="0">slog.Debug("parsed version", slog.Int("version", int(cs.Version)))

        if cs.Version != Version1 &amp;&amp; cs.Version != Version2 </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported version: %d", cs.Version)
        }</span>

        // Read number of colors
        <span class="cov0" title="0">var numColors uint16
        if err := binary.Read(buf, binary.BigEndian, &amp;numColors); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read number of colors: %w", err)
        }</span>

        <span class="cov0" title="0">slog.Debug("parsed color count", slog.Int("count", int(numColors)))

        cs.Colors = make([]*Color, numColors)

        // Read colors
        for i := range cs.Colors </span><span class="cov0" title="0">{
                color := &amp;Color{}

                // Read color space
                if err := binary.Read(buf, binary.BigEndian, &amp;color.ColorSpace); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read color space for color %d: %w", i, err)
                }</span>

                // Read color values
                <span class="cov0" title="0">if err := binary.Read(buf, binary.BigEndian, &amp;color.Values); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read values for color %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">slog.Debug("parsed color", slog.Int("index", i), slog.String("colorspace", color.ColorSpace.String()), slog.Any("values", color.Values))

                cs.Colors[i] = color</span>
        }

        // If version 2, read color names
        <span class="cov0" title="0">if cs.Version == Version2 </span><span class="cov0" title="0">{
                // Skip to start of version 2 data by reading version and count again
                if err := binary.Read(buf, binary.BigEndian, &amp;cs.Version); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read version 2 header: %w", err)
                }</span>

                <span class="cov0" title="0">var numColors2 uint16
                if err := binary.Read(buf, binary.BigEndian, &amp;numColors2); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read version 2 color count: %w", err)
                }</span>

                <span class="cov0" title="0">if numColors2 != numColors </span><span class="cov0" title="0">{
                        return fmt.Errorf("version 2 color count mismatch: expected %d, got %d", numColors, numColors2)
                }</span>

                // Read color names
                <span class="cov0" title="0">for i := range cs.Colors </span><span class="cov0" title="0">{
                        // Read color space and values again (version 2 repeats this data)
                        var colorSpace ColorSpace
                        var values [4]uint16

                        if err := binary.Read(buf, binary.BigEndian, &amp;colorSpace); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to read v2 color space for color %d: %w", i, err)
                        }</span>

                        <span class="cov0" title="0">if err := binary.Read(buf, binary.BigEndian, &amp;values); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to read v2 values for color %d: %w", i, err)
                        }</span>

                        // Read color name
                        <span class="cov0" title="0">name, err := readString(slog.With("color", i, "field", "name"), buf)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to read name for color %d: %w", i, err)
                        }</span>

                        <span class="cov0" title="0">cs.Colors[i].Name = name

                        slog.Debug("parsed color name", slog.Int("index", i), slog.String("name", name))</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func readString(log *slog.Logger, r io.Reader) (string, error) <span class="cov0" title="0">{
        var length uint32

        if err := binary.Read(r, binary.BigEndian, &amp;length); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read string length: %w", err)
        }</span>

        <span class="cov0" title="0">log.Debug("read string length", slog.Uint64("length", uint64(length)))

        if length == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        // Read UTF-16 encoded string
        <span class="cov0" title="0">s := make([]byte, 2*length)
        if _, err := io.ReadFull(r, s); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read string bytes: %w", err)
        }</span>

        // Convert UTF-16 to UTF-8
        <span class="cov0" title="0">ret := &amp;bytes.Buffer{}
        u16s := make([]uint16, 1)
        b8s := make([]byte, 4)

        for i, l := 0, len(s); i &lt; l; i += 2 </span><span class="cov0" title="0">{
                u16s[0] = uint16(s[i+1]) + (uint16(s[i]) &lt;&lt; 8)
                if u16s[0] == 0 </span><span class="cov0" title="0">{ // Null terminator
                        break</span>
                }
                <span class="cov0" title="0">r := utf16.Decode(u16s)
                n := utf8.EncodeRune(b8s, r[0])
                if _, err := ret.Write(b8s[:n]); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to write rune at position %d: %w", i, err)
                }</span>
        }

        <span class="cov0" title="0">return ret.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package types

import "unicode/utf16"

type UnicodeString string

func (s UnicodeString) MarshalBinary() (data []byte, err error) <span class="cov0" title="0">{
        runes := []rune(s)
        encoded := utf16.Encode(runes)

        data = make([]byte, len(encoded)*2)
        for i, u16 := range encoded </span><span class="cov0" title="0">{
                data[i*2] = byte(u16 &gt;&gt; 8)
                data[i*2+1] = byte(u16)
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

func (s UnicodeString) String() string <span class="cov0" title="0">{
        return string(s)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package color

import (
        "fmt"
        "math"
)

// Color represents a color in any color space.
type Color interface {
        // String returns a string representation of the color.
        String() string

        // ColorSpace returns the name of the color space.
        ColorSpace() string

        // ToRGB converts the color to RGB color space.
        ToRGB() RGB

        // ToCMYK converts the color to CMYK color space.
        ToCMYK() CMYK

        // ToLAB converts the color to LAB color space.
        ToLAB() LAB

        // ToHSB converts the color to HSB color space.
        ToHSB() HSB
}

// RGB represents a color in RGB color space.
type RGB struct {
        R, G, B uint8
}

// NewRGB creates a new RGB color with validation.
func NewRGB(r, g, b uint8) RGB <span class="cov8" title="1">{
        return RGB{R: r, G: g, B: b}
}</span>

// NewRGBFromFloat creates a new RGB color from float64 values (0.0-1.0).
func NewRGBFromFloat(r, g, b float64) RGB <span class="cov8" title="1">{
        return RGB{
                R: uint8(math.Round(clamp(r, 0, 1) * 255)),
                G: uint8(math.Round(clamp(g, 0, 1) * 255)),
                B: uint8(math.Round(clamp(b, 0, 1) * 255)),
        }
}</span>

func (c RGB) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("RGB(%d, %d, %d)", c.R, c.G, c.B)
}</span>

func (c RGB) ColorSpace() string <span class="cov8" title="1">{
        return "RGB"
}</span>

func (c RGB) ToRGB() RGB <span class="cov8" title="1">{
        return c
}</span>

func (c RGB) ToCMYK() CMYK <span class="cov8" title="1">{
        r := float64(c.R) / 255.0
        g := float64(c.G) / 255.0
        b := float64(c.B) / 255.0

        k := 1.0 - math.Max(r, math.Max(g, b))
        if k == 1.0 </span><span class="cov8" title="1">{
                return CMYK{C: 0, M: 0, Y: 0, K: 100}
        }</span>

        <span class="cov8" title="1">cy := (1.0 - r - k) / (1.0 - k)
        mg := (1.0 - g - k) / (1.0 - k)
        ye := (1.0 - b - k) / (1.0 - k)

        return CMYK{
                C: uint8(math.Round(cy * 100)),
                M: uint8(math.Round(mg * 100)),
                Y: uint8(math.Round(ye * 100)),
                K: uint8(math.Round(k * 100)),
        }</span>
}

func (c RGB) ToLAB() LAB <span class="cov8" title="1">{
        // Convert RGB to XYZ first
        r := float64(c.R) / 255.0
        g := float64(c.G) / 255.0
        b := float64(c.B) / 255.0

        // Apply gamma correction
        if r &gt; 0.04045 </span><span class="cov8" title="1">{
                r = math.Pow((r+0.055)/1.055, 2.4)
        }</span> else<span class="cov0" title="0"> {
                r = r / 12.92
        }</span>

        <span class="cov8" title="1">if g &gt; 0.04045 </span><span class="cov8" title="1">{
                g = math.Pow((g+0.055)/1.055, 2.4)
        }</span> else<span class="cov0" title="0"> {
                g = g / 12.92
        }</span>

        <span class="cov8" title="1">if b &gt; 0.04045 </span><span class="cov8" title="1">{
                b = math.Pow((b+0.055)/1.055, 2.4)
        }</span> else<span class="cov0" title="0"> {
                b = b / 12.92
        }</span>

        // Convert to XYZ using sRGB matrix
        <span class="cov8" title="1">x := r*0.4124564 + g*0.3575761 + b*0.1804375
        y := r*0.2126729 + g*0.7151522 + b*0.0721750
        z := r*0.0193339 + g*0.1191920 + b*0.9503041

        // Convert XYZ to LAB
        // D65 illuminant
        xn := 0.95047
        yn := 1.00000
        zn := 1.08883

        x = x / xn
        y = y / yn
        z = z / zn

        fx := labF(x)
        fy := labF(y)
        fz := labF(z)

        l := 116*fy - 16
        a := 500 * (fx - fy)
        b2 := 200 * (fy - fz)

        return LAB{
                L: int8(math.Round(clamp(l, 0, 100))),
                A: int8(math.Round(clamp(a, -128, 127))),
                B: int8(math.Round(clamp(b2, -128, 127))),
        }</span>
}

func (c RGB) ToHSB() HSB <span class="cov8" title="1">{
        r := float64(c.R) / 255.0
        g := float64(c.G) / 255.0
        b := float64(c.B) / 255.0

        max := math.Max(r, math.Max(g, b))
        min := math.Min(r, math.Min(g, b))
        delta := max - min

        var h, s float64
        brightness := max

        if delta == 0 </span><span class="cov8" title="1">{
                h = 0
                s = 0
        }</span> else<span class="cov8" title="1"> {
                s = delta / max

                switch max </span>{
                case r:<span class="cov8" title="1">
                        h = 60 * (math.Mod((g-b)/delta, 6))</span>
                case g:<span class="cov8" title="1">
                        h = 60 * ((b-r)/delta + 2)</span>
                case b:<span class="cov8" title="1">
                        h = 60 * ((r-g)/delta + 4)</span>
                }

                <span class="cov8" title="1">if h &lt; 0 </span><span class="cov8" title="1">{
                        h += 360
                }</span>
        }

        <span class="cov8" title="1">return HSB{
                H: uint16(math.Round(h)),
                S: uint8(math.Round(s * 100)),
                B: uint8(math.Round(brightness * 100)),
        }</span>
}

// CMYK represents a color in CMYK color space.
type CMYK struct {
        C, M, Y, K uint8 // 0-100
}

// NewCMYK creates a new CMYK color with validation.
func NewCMYK(c, m, y, k uint8) CMYK <span class="cov8" title="1">{
        return CMYK{
                C: clampUint8(c, 0, 100),
                M: clampUint8(m, 0, 100),
                Y: clampUint8(y, 0, 100),
                K: clampUint8(k, 0, 100),
        }
}</span>

func (c CMYK) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("CMYK(%d%%, %d%%, %d%%, %d%%)", c.C, c.M, c.Y, c.K)
}</span>

func (c CMYK) ColorSpace() string <span class="cov8" title="1">{
        return "CMYK"
}</span>

func (c CMYK) ToRGB() RGB <span class="cov8" title="1">{
        cy := float64(c.C) / 100.0
        mg := float64(c.M) / 100.0
        ye := float64(c.Y) / 100.0
        k := float64(c.K) / 100.0

        r := 255 * (1 - cy) * (1 - k)
        g := 255 * (1 - mg) * (1 - k)
        b := 255 * (1 - ye) * (1 - k)

        return RGB{
                R: uint8(math.Round(r)),
                G: uint8(math.Round(g)),
                B: uint8(math.Round(b)),
        }
}</span>

func (c CMYK) ToCMYK() CMYK <span class="cov8" title="1">{
        return c
}</span>

func (c CMYK) ToLAB() LAB <span class="cov0" title="0">{
        return c.ToRGB().ToLAB()
}</span>

func (c CMYK) ToHSB() HSB <span class="cov0" title="0">{
        return c.ToRGB().ToHSB()
}</span>

// LAB represents a color in LAB color space.
type LAB struct {
        L    int8 // 0-100
        A, B int8 // -128 to 127
}

// NewLAB creates a new LAB color with validation.
func NewLAB(l, a, b int8) LAB <span class="cov8" title="1">{
        return LAB{
                L: clampInt8(l, 0, 100),
                A: a,
                B: b,
        }
}</span>

func (c LAB) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("LAB(%d, %d, %d)", c.L, c.A, c.B)
}</span>

func (c LAB) ColorSpace() string <span class="cov8" title="1">{
        return "LAB"
}</span>

func (c LAB) ToRGB() RGB <span class="cov8" title="1">{
        // Convert LAB to XYZ first
        l := float64(c.L)
        a := float64(c.A)
        b := float64(c.B)

        fy := (l + 16) / 116
        fx := a/500 + fy
        fz := fy - b/200

        x := labFInv(fx)
        y := labFInv(fy)
        z := labFInv(fz)

        // D65 illuminant
        xn := 0.95047
        yn := 1.00000
        zn := 1.08883

        x = x * xn
        y = y * yn
        z = z * zn

        // Convert XYZ to RGB
        r := x*3.2404542 + y*-1.5371385 + z*-0.4985314
        g := x*-0.9692660 + y*1.8760108 + z*0.0415560
        b2 := x*0.0556434 + y*-0.2040259 + z*1.0572252

        // Apply gamma correction
        if r &gt; 0.0031308 </span><span class="cov8" title="1">{
                r = 1.055*math.Pow(r, 1/2.4) - 0.055
        }</span> else<span class="cov0" title="0"> {
                r = 12.92 * r
        }</span>

        <span class="cov8" title="1">if g &gt; 0.0031308 </span><span class="cov8" title="1">{
                g = 1.055*math.Pow(g, 1/2.4) - 0.055
        }</span> else<span class="cov0" title="0"> {
                g = 12.92 * g
        }</span>

        <span class="cov8" title="1">if b2 &gt; 0.0031308 </span><span class="cov8" title="1">{
                b2 = 1.055*math.Pow(b2, 1/2.4) - 0.055
        }</span> else<span class="cov0" title="0"> {
                b2 = 12.92 * b2
        }</span>

        <span class="cov8" title="1">return RGB{
                R: uint8(math.Round(clamp(r, 0, 1) * 255)),
                G: uint8(math.Round(clamp(g, 0, 1) * 255)),
                B: uint8(math.Round(clamp(b2, 0, 1) * 255)),
        }</span>
}

func (c LAB) ToCMYK() CMYK <span class="cov0" title="0">{
        return c.ToRGB().ToCMYK()
}</span>

func (c LAB) ToLAB() LAB <span class="cov8" title="1">{
        return c
}</span>

func (c LAB) ToHSB() HSB <span class="cov0" title="0">{
        return c.ToRGB().ToHSB()
}</span>

// HSB represents a color in HSB (HSV) color space.
type HSB struct {
        H uint16 // 0-359
        S uint8  // 0-100
        B uint8  // 0-100
}

// NewHSB creates a new HSB color with validation.
func NewHSB(h uint16, s, b uint8) HSB <span class="cov8" title="1">{
        return HSB{
                H: h % 360,
                S: clampUint8(s, 0, 100),
                B: clampUint8(b, 0, 100),
        }
}</span>

func (c HSB) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("HSB(%d°, %d%%, %d%%)", c.H, c.S, c.B)
}</span>

func (c HSB) ColorSpace() string <span class="cov8" title="1">{
        return "HSB"
}</span>

func (c HSB) ToRGB() RGB <span class="cov8" title="1">{
        h := float64(c.H)
        s := float64(c.S) / 100.0
        v := float64(c.B) / 100.0

        chroma := v * s
        x := chroma * (1 - math.Abs(math.Mod(h/60, 2)-1))
        m := v - chroma

        var r, g, b float64

        switch </span>{
        case h &lt; 60:<span class="cov8" title="1">
                r, g, b = chroma, x, 0</span>
        case h &lt; 120:<span class="cov8" title="1">
                r, g, b = x, chroma, 0</span>
        case h &lt; 180:<span class="cov8" title="1">
                r, g, b = 0, chroma, x</span>
        case h &lt; 240:<span class="cov8" title="1">
                r, g, b = 0, x, chroma</span>
        case h &lt; 300:<span class="cov8" title="1">
                r, g, b = x, 0, chroma</span>
        default:<span class="cov8" title="1">
                r, g, b = chroma, 0, x</span>
        }

        <span class="cov8" title="1">return RGB{
                R: uint8(math.Round((r + m) * 255)),
                G: uint8(math.Round((g + m) * 255)),
                B: uint8(math.Round((b + m) * 255)),
        }</span>
}

func (c HSB) ToCMYK() CMYK <span class="cov0" title="0">{
        return c.ToRGB().ToCMYK()
}</span>

func (c HSB) ToLAB() LAB <span class="cov0" title="0">{
        return c.ToRGB().ToLAB()
}</span>

func (c HSB) ToHSB() HSB <span class="cov8" title="1">{
        return c
}</span>

// Helper functions

func clamp(value, min, max float64) float64 <span class="cov8" title="1">{
        if value &lt; min </span><span class="cov8" title="1">{
                return min
        }</span>
        <span class="cov8" title="1">if value &gt; max </span><span class="cov8" title="1">{
                return max
        }</span>
        <span class="cov8" title="1">return value</span>
}

func clampUint8(value, min, max uint8) uint8 <span class="cov8" title="1">{
        if value &lt; min </span><span class="cov0" title="0">{
                return min
        }</span>
        <span class="cov8" title="1">if value &gt; max </span><span class="cov8" title="1">{
                return max
        }</span>
        <span class="cov8" title="1">return value</span>
}

func clampInt8(value, min, max int8) int8 <span class="cov8" title="1">{
        if value &lt; min </span><span class="cov0" title="0">{
                return min
        }</span>
        <span class="cov8" title="1">if value &gt; max </span><span class="cov0" title="0">{
                return max
        }</span>
        <span class="cov8" title="1">return value</span>
}

func labF(t float64) float64 <span class="cov8" title="1">{
        if t &gt; 0.008856 </span><span class="cov8" title="1">{
                return math.Pow(t, 1.0/3.0)
        }</span>
        <span class="cov0" title="0">return 7.787*t + 16.0/116.0</span>
}

func labFInv(t float64) float64 <span class="cov8" title="1">{
        if t &gt; 0.206893 </span><span class="cov8" title="1">{
                return math.Pow(t, 3)
        }</span>
        <span class="cov0" title="0">return (t - 16.0/116.0) / 7.787</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package palette

import (
        paletteio "github.com/kennyp/palette/io"
        "github.com/kennyp/palette/io/colorbook"
        "github.com/kennyp/palette/io/colorswatch"
        "github.com/kennyp/palette/io/csv"
        "github.com/kennyp/palette/io/json"
)

func init() <span class="cov8" title="1">{
        // Register all format importers and exporters with the default registry

        // Adobe Color Book (.acb)
        paletteio.DefaultRegistry.RegisterImporter(colorbook.NewImporter())
        paletteio.DefaultRegistry.RegisterExporter(colorbook.NewExporter())

        // Adobe Color Swatch (.aco)
        paletteio.DefaultRegistry.RegisterImporter(colorswatch.NewImporter())
        paletteio.DefaultRegistry.RegisterExporter(colorswatch.NewExporter())

        // CSV
        paletteio.DefaultRegistry.RegisterImporter(csv.NewImporter())
        paletteio.DefaultRegistry.RegisterExporter(csv.NewExporter())

        // JSON
        paletteio.DefaultRegistry.RegisterImporter(json.NewImporter())
        paletteio.DefaultRegistry.RegisterExporter(json.NewExporter())
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package colorbook

import (
        "fmt"
        "io"

        "github.com/kennyp/palette/adobe/colorbook"
        "github.com/kennyp/palette/color"
        "github.com/kennyp/palette/palette"
)

// Importer implements importing Adobe Color Book (.acb) files.
type Importer struct{}

// NewImporter creates a new Adobe Color Book importer.
func NewImporter() *Importer <span class="cov0" title="0">{
        return &amp;Importer{}
}</span>

// Import reads an Adobe Color Book file and converts it to a palette.
func (i *Importer) Import(r io.Reader) (*palette.Palette, error) <span class="cov0" title="0">{
        // Read all data from reader
        data, err := io.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read color book data: %w", err)
        }</span>

        // Parse Adobe Color Book
        <span class="cov0" title="0">var acb colorbook.ColorBook
        if err := acb.UnmarshalBinary(data); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse color book: %w", err)
        }</span>

        // Create palette
        <span class="cov0" title="0">p := palette.New(acb.Title)
        if acb.Description != "" </span><span class="cov0" title="0">{
                p.Description = acb.Description
        }</span>

        // Store metadata
        <span class="cov0" title="0">p.SetMetadata("book_id", acb.ID)
        p.SetMetadata("version", acb.Version)
        p.SetMetadata("prefix", acb.Prefix)
        p.SetMetadata("postfix", acb.Postfix)
        p.SetMetadata("colors_per_page", acb.ColorsPerPage)
        p.SetMetadata("key_color_page", acb.KeyColorPage)
        p.SetMetadata("color_type", acb.ColorType)
        p.SetMetadata("format", "Adobe Color Book")

        // Convert colors
        for _, c := range acb.Colors </span><span class="cov0" title="0">{
                paletteColor, err := convertAdobeColor(c, acb.ColorType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to convert color %s: %w", c.Name, err)
                }</span>

                <span class="cov0" title="0">p.Add(paletteColor, c.Name)</span>
        }

        <span class="cov0" title="0">return p, nil</span>
}

// CanImport returns true if this importer can handle the given format.
func (i *Importer) CanImport(format string) bool <span class="cov0" title="0">{
        return format == ".acb" || format == "colorbook"
}</span>

// SupportedFormats returns the list of supported formats.
func (i *Importer) SupportedFormats() []string <span class="cov0" title="0">{
        return []string{".acb", "colorbook"}
}</span>

// Exporter implements exporting to Adobe Color Book (.acb) files.
type Exporter struct{}

// NewExporter creates a new Adobe Color Book exporter.
func NewExporter() *Exporter <span class="cov0" title="0">{
        return &amp;Exporter{}
}</span>

// Export converts a palette to Adobe Color Book format and writes it.
func (e *Exporter) Export(p *palette.Palette, w io.Writer) error <span class="cov0" title="0">{
        // Create Adobe Color Book
        acb := &amp;colorbook.ColorBook{
                Title:       p.Name,
                Description: p.Description,
                Version:     colorbook.DefaultVersion,
        }

        // Set metadata if available
        if bookID, ok := p.GetMetadata("book_id"); ok </span><span class="cov0" title="0">{
                if id, ok := bookID.(colorbook.BookID); ok </span><span class="cov0" title="0">{
                        acb.ID = id
                }</span>
        }

        <span class="cov0" title="0">if version, ok := p.GetMetadata("version"); ok </span><span class="cov0" title="0">{
                if v, ok := version.(uint16); ok </span><span class="cov0" title="0">{
                        acb.Version = v
                }</span>
        }

        <span class="cov0" title="0">if prefix, ok := p.GetMetadata("prefix"); ok </span><span class="cov0" title="0">{
                if s, ok := prefix.(string); ok </span><span class="cov0" title="0">{
                        acb.Prefix = s
                }</span>
        }

        <span class="cov0" title="0">if postfix, ok := p.GetMetadata("postfix"); ok </span><span class="cov0" title="0">{
                if s, ok := postfix.(string); ok </span><span class="cov0" title="0">{
                        acb.Postfix = s
                }</span>
        }

        <span class="cov0" title="0">if colorsPerPage, ok := p.GetMetadata("colors_per_page"); ok </span><span class="cov0" title="0">{
                if cpp, ok := colorsPerPage.(uint16); ok </span><span class="cov0" title="0">{
                        acb.ColorsPerPage = cpp
                }</span>
        }

        <span class="cov0" title="0">if keyColorPage, ok := p.GetMetadata("key_color_page"); ok </span><span class="cov0" title="0">{
                if kcp, ok := keyColorPage.(uint16); ok </span><span class="cov0" title="0">{
                        acb.KeyColorPage = kcp
                }</span>
        }

        <span class="cov0" title="0">if colorType, ok := p.GetMetadata("color_type"); ok </span><span class="cov0" title="0">{
                if ct, ok := colorType.(colorbook.ColorType); ok </span><span class="cov0" title="0">{
                        acb.ColorType = ct
                }</span>
        } else<span class="cov0" title="0"> {
                // Default to RGB if no color type specified
                acb.ColorType = colorbook.ColorTypeRGB
        }</span>

        // Convert colors
        <span class="cov0" title="0">acb.Colors = make([]*colorbook.Color, 0, p.Len())
        for i := range p.Len() </span><span class="cov0" title="0">{
                namedColor, err := p.Get(i)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get color at index %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">adobeColor, err := convertToAdobeColor(namedColor.Color, namedColor.Name, acb.ColorType)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to convert color %s: %w", namedColor.Name, err)
                }</span>

                <span class="cov0" title="0">acb.Colors = append(acb.Colors, adobeColor)</span>
        }

        // Marshal and write
        <span class="cov0" title="0">data, err := acb.MarshalBinary()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal color book: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = w.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write color book data: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CanExport returns true if this exporter can handle the given format.
func (e *Exporter) CanExport(format string) bool <span class="cov0" title="0">{
        return format == ".acb" || format == "colorbook"
}</span>

// SupportedFormats returns the list of supported formats.
func (e *Exporter) SupportedFormats() []string <span class="cov0" title="0">{
        return []string{".acb", "colorbook"}
}</span>

// Helper functions

// convertAdobeColor converts an Adobe Color Book color to a palette color.
func convertAdobeColor(c *colorbook.Color, colorType colorbook.ColorType) (color.Color, error) <span class="cov0" title="0">{
        switch colorType </span>{
        case colorbook.ColorTypeRGB:<span class="cov0" title="0">
                // Adobe RGB uses 0-255 values stored in first 3 bytes
                return color.NewRGB(c.Components[0], c.Components[1], c.Components[2]), nil</span>

        case colorbook.ColorTypeCMYK:<span class="cov0" title="0">
                // Adobe CMYK uses 0-100 values stored in first 4 bytes
                // But Components is only 3 bytes, so we need to handle this differently
                // For now, assume the values are scaled 0-255 and convert to 0-100
                cy := uint8((float64(c.Components[0]) / 255.0) * 100)
                mg := uint8((float64(c.Components[1]) / 255.0) * 100)
                ye := uint8((float64(c.Components[2]) / 255.0) * 100)
                // K value might be stored elsewhere or derived
                k := uint8(0) // Default to 0 for now
                return color.NewCMYK(cy, mg, ye, k), nil</span>

        case colorbook.ColorTypeLab:<span class="cov0" title="0">
                // Adobe LAB format
                l := int8(c.Components[0])
                a := int8(c.Components[1])
                b := int8(c.Components[2])
                return color.NewLAB(l, a, b), nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported color type: %v", colorType)</span>
        }
}

// convertToAdobeColor converts a palette color to an Adobe Color Book color.
func convertToAdobeColor(c color.Color, name string, targetType colorbook.ColorType) (*colorbook.Color, error) <span class="cov0" title="0">{
        adobeColor := &amp;colorbook.Color{
                Name: name,
        }

        switch targetType </span>{
        case colorbook.ColorTypeRGB:<span class="cov0" title="0">
                rgb := c.ToRGB()
                adobeColor.Components = [3]byte{rgb.R, rgb.G, rgb.B}</span>

        case colorbook.ColorTypeCMYK:<span class="cov0" title="0">
                cmyk := c.ToCMYK()
                // Convert CMYK percentages to 0-255 scale for storage
                cy := uint8((float64(cmyk.C) / 100.0) * 255)
                mg := uint8((float64(cmyk.M) / 100.0) * 255)
                ye := uint8((float64(cmyk.Y) / 100.0) * 255)
                adobeColor.Components = [3]byte{cy, mg, ye}</span>

        case colorbook.ColorTypeLab:<span class="cov0" title="0">
                lab := c.ToLAB()
                adobeColor.Components = [3]byte{byte(lab.L), byte(lab.A), byte(lab.B)}</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported target color type: %v", targetType)</span>
        }

        <span class="cov0" title="0">return adobeColor, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package colorswatch

import (
        "fmt"
        "io"

        "github.com/kennyp/palette/adobe/colorswatch"
        "github.com/kennyp/palette/color"
        "github.com/kennyp/palette/palette"
)

// Importer implements importing Adobe Color Swatch (.aco) files.
type Importer struct{}

// NewImporter creates a new Adobe Color Swatch importer.
func NewImporter() *Importer <span class="cov0" title="0">{
        return &amp;Importer{}
}</span>

// Import reads an Adobe Color Swatch file and converts it to a palette.
func (i *Importer) Import(r io.Reader) (*palette.Palette, error) <span class="cov0" title="0">{
        // Read all data from reader
        data, err := io.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read color swatch data: %w", err)
        }</span>

        // Parse Adobe Color Swatch
        <span class="cov0" title="0">var acs colorswatch.ColorSwatch
        if err := acs.UnmarshalBinary(data); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse color swatch: %w", err)
        }</span>

        // Create palette
        <span class="cov0" title="0">paletteName := "Color Swatch"
        if acs.Version == colorswatch.Version2 </span><span class="cov0" title="0">{
                paletteName = "Color Swatch (with names)"
        }</span>
        <span class="cov0" title="0">p := palette.New(paletteName)

        // Store metadata
        p.SetMetadata("version", acs.Version)
        p.SetMetadata("format", "Adobe Color Swatch")

        // Convert colors
        for i, c := range acs.Colors </span><span class="cov0" title="0">{
                paletteColor, err := convertAdobeSwatchColor(c)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to convert color at index %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">colorName := c.Name
                if colorName == "" </span><span class="cov0" title="0">{
                        colorName = fmt.Sprintf("Color %d", i+1)
                }</span>

                <span class="cov0" title="0">p.Add(paletteColor, colorName)</span>
        }

        <span class="cov0" title="0">return p, nil</span>
}

// CanImport returns true if this importer can handle the given format.
func (i *Importer) CanImport(format string) bool <span class="cov0" title="0">{
        return format == ".aco" || format == "colorswatch" || format == "swatch"
}</span>

// SupportedFormats returns the list of supported formats.
func (i *Importer) SupportedFormats() []string <span class="cov0" title="0">{
        return []string{".aco", "colorswatch", "swatch"}
}</span>

// Exporter implements exporting to Adobe Color Swatch (.aco) files.
type Exporter struct {
        // Version specifies the ACO version to export (1 or 2)
        Version uint16
}

// NewExporter creates a new Adobe Color Swatch exporter.
// By default, exports version 2 (with color names).
func NewExporter() *Exporter <span class="cov0" title="0">{
        return &amp;Exporter{
                Version: colorswatch.Version2,
        }
}</span>

// NewExporterV1 creates a new Adobe Color Swatch exporter for version 1 (no names).
func NewExporterV1() *Exporter <span class="cov0" title="0">{
        return &amp;Exporter{
                Version: colorswatch.Version1,
        }
}</span>

// Export converts a palette to Adobe Color Swatch format and writes it.
func (e *Exporter) Export(p *palette.Palette, w io.Writer) error <span class="cov0" title="0">{
        // Create Adobe Color Swatch
        acs := &amp;colorswatch.ColorSwatch{
                Version: e.Version,
        }

        // Override version from metadata if available
        if version, ok := p.GetMetadata("version"); ok </span><span class="cov0" title="0">{
                if v, ok := version.(uint16); ok &amp;&amp; (v == colorswatch.Version1 || v == colorswatch.Version2) </span><span class="cov0" title="0">{
                        acs.Version = v
                }</span>
        }

        // Convert colors
        <span class="cov0" title="0">acs.Colors = make([]*colorswatch.Color, 0, p.Len())
        for i := range p.Len() </span><span class="cov0" title="0">{
                namedColor, err := p.Get(i)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get color at index %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">adobeColor, err := convertToAdobeSwatchColor(namedColor.Color, namedColor.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to convert color %s: %w", namedColor.Name, err)
                }</span>

                // Only include names for version 2
                <span class="cov0" title="0">if acs.Version == colorswatch.Version1 </span><span class="cov0" title="0">{
                        adobeColor.Name = ""
                }</span>

                <span class="cov0" title="0">acs.Colors = append(acs.Colors, adobeColor)</span>
        }

        // Marshal and write
        <span class="cov0" title="0">data, err := acs.MarshalBinary()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal color swatch: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = w.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write color swatch data: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CanExport returns true if this exporter can handle the given format.
func (e *Exporter) CanExport(format string) bool <span class="cov0" title="0">{
        return format == ".aco" || format == "colorswatch" || format == "swatch"
}</span>

// SupportedFormats returns the list of supported formats.
func (e *Exporter) SupportedFormats() []string <span class="cov0" title="0">{
        return []string{".aco", "colorswatch", "swatch"}
}</span>

// Helper functions

// convertAdobeSwatchColor converts an Adobe Color Swatch color to a palette color.
func convertAdobeSwatchColor(c *colorswatch.Color) (color.Color, error) <span class="cov0" title="0">{
        switch c.ColorSpace </span>{
        case colorswatch.ColorSpaceRGB:<span class="cov0" title="0">
                // Adobe ACO RGB values are 0-65535, convert to 0-255
                r := uint8(c.Values[0] &gt;&gt; 8)
                g := uint8(c.Values[1] &gt;&gt; 8)
                b := uint8(c.Values[2] &gt;&gt; 8)
                return color.NewRGB(r, g, b), nil</span>

        case colorswatch.ColorSpaceHSB:<span class="cov0" title="0">
                // Adobe ACO HSB: H=0-360*182, S=0-100*655, B=0-100*655
                h := uint16(c.Values[0] / 182)
                s := uint8(c.Values[1] / 655)
                b := uint8(c.Values[2] / 655)
                return color.NewHSB(h, s, b), nil</span>

        case colorswatch.ColorSpaceCMYK:<span class="cov0" title="0">
                // Adobe ACO CMYK values are 0-10000 (representing 0-100%)
                cy := uint8(c.Values[0] / 100)
                mg := uint8(c.Values[1] / 100)
                ye := uint8(c.Values[2] / 100)
                k := uint8(c.Values[3] / 100)
                return color.NewCMYK(cy, mg, ye, k), nil</span>

        case colorswatch.ColorSpaceLab:<span class="cov0" title="0">
                // Adobe ACO LAB format
                // L: 0-10000 (0-100), a: -12800 to 12700 (-128 to 127), b: -12800 to 12700 (-128 to 127)
                l := int8(c.Values[0] / 100)
                a := int8((int32(c.Values[1]) - 12800) / 100)
                b := int8((int32(c.Values[2]) - 12800) / 100)
                return color.NewLAB(l, a, b), nil</span>

        case colorswatch.ColorSpaceGrayscale:<span class="cov0" title="0">
                // Grayscale: convert to RGB
                gray := uint8(c.Values[0] / 100)
                return color.NewRGB(gray, gray, gray), nil</span>

        case colorswatch.ColorSpacePantone,
                colorswatch.ColorSpaceFocoltone,
                colorswatch.ColorSpaceTruematch,
                colorswatch.ColorSpaceToyo,
                colorswatch.ColorSpaceHKS:<span class="cov0" title="0">
                // For spot colors, convert to RGB as approximation
                // This is a simplification - in reality these would need proper color management
                r := uint8(c.Values[0] &gt;&gt; 8)
                g := uint8(c.Values[1] &gt;&gt; 8)
                b := uint8(c.Values[2] &gt;&gt; 8)
                return color.NewRGB(r, g, b), nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported color space: %v", c.ColorSpace)</span>
        }
}

// convertToAdobeSwatchColor converts a palette color to an Adobe Color Swatch color.
func convertToAdobeSwatchColor(c color.Color, name string) (*colorswatch.Color, error) <span class="cov0" title="0">{
        adobeColor := &amp;colorswatch.Color{
                Name: name,
        }

        // Determine the best color space based on the input color type
        switch c.ColorSpace() </span>{
        case "RGB":<span class="cov0" title="0">
                rgb := c.ToRGB()
                adobeColor.ColorSpace = colorswatch.ColorSpaceRGB
                // Convert 0-255 to 0-65535
                adobeColor.Values = [4]uint16{
                        uint16(rgb.R) &lt;&lt; 8,
                        uint16(rgb.G) &lt;&lt; 8,
                        uint16(rgb.B) &lt;&lt; 8,
                        0, // Alpha/unused
                }</span>

        case "HSB":<span class="cov0" title="0">
                hsb := c.ToHSB()
                adobeColor.ColorSpace = colorswatch.ColorSpaceHSB
                // Convert to Adobe ACO HSB format
                adobeColor.Values = [4]uint16{
                        uint16(hsb.H) * 182, // H: 0-360 -&gt; 0-65520
                        uint16(hsb.S) * 655, // S: 0-100 -&gt; 0-65500
                        uint16(hsb.B) * 655, // B: 0-100 -&gt; 0-65500
                        0,                   // Unused
                }</span>

        case "CMYK":<span class="cov0" title="0">
                cmyk := c.ToCMYK()
                adobeColor.ColorSpace = colorswatch.ColorSpaceCMYK
                // Convert 0-100 to 0-10000
                adobeColor.Values = [4]uint16{
                        uint16(cmyk.C) * 100,
                        uint16(cmyk.M) * 100,
                        uint16(cmyk.Y) * 100,
                        uint16(cmyk.K) * 100,
                }</span>

        case "LAB":<span class="cov0" title="0">
                lab := c.ToLAB()
                adobeColor.ColorSpace = colorswatch.ColorSpaceLab
                // Convert to Adobe ACO LAB format
                adobeColor.Values = [4]uint16{
                        uint16(lab.L) * 100,              // L: 0-100 -&gt; 0-10000
                        uint16(int32(lab.A)*100 + 12800), // a: -128 to 127 -&gt; 0 to 25500
                        uint16(int32(lab.B)*100 + 12800), // b: -128 to 127 -&gt; 0 to 25500
                        0,                                // Unused
                }</span>

        default:<span class="cov0" title="0">
                // Default to RGB conversion
                rgb := c.ToRGB()
                adobeColor.ColorSpace = colorswatch.ColorSpaceRGB
                adobeColor.Values = [4]uint16{
                        uint16(rgb.R) &lt;&lt; 8,
                        uint16(rgb.G) &lt;&lt; 8,
                        uint16(rgb.B) &lt;&lt; 8,
                        0,
                }</span>
        }

        <span class="cov0" title="0">return adobeColor, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package csv

import (
        "encoding/csv"
        "fmt"
        "io"
        "strconv"
        "strings"

        "github.com/kennyp/palette/color"
        "github.com/kennyp/palette/palette"
)

// Importer implements importing CSV files containing color data.
type Importer struct {
        // Delimiter specifies the field delimiter (default: comma)
        Delimiter rune
        // HasHeader indicates if the first row contains column headers
        HasHeader bool
        // ColorFormat specifies the expected color format in the CSV
        ColorFormat ColorFormat
}

// ColorFormat represents different ways colors can be represented in CSV.
type ColorFormat int

const (
        // FormatAuto attempts to auto-detect the color format
        FormatAuto ColorFormat = iota
        // FormatRGB expects R,G,B columns (0-255)
        FormatRGB
        // FormatRGBFloat expects R,G,B columns (0.0-1.0)
        FormatRGBFloat
        // FormatHex expects a single hex color column (#RRGGBB)
        FormatHex
        // FormatCMYK expects C,M,Y,K columns (0-100)
        FormatCMYK
        // FormatHSB expects H,S,B columns (H: 0-360, S,B: 0-100)
        FormatHSB
        // FormatLAB expects L,A,B columns
        FormatLAB
)

// NewImporter creates a new CSV importer with default settings.
func NewImporter() *Importer <span class="cov8" title="1">{
        return &amp;Importer{
                Delimiter:   ',',
                HasHeader:   true,
                ColorFormat: FormatAuto,
        }
}</span>

// Import reads a CSV file and converts it to a palette.
func (i *Importer) Import(r io.Reader) (*palette.Palette, error) <span class="cov8" title="1">{
        csvReader := csv.NewReader(r)
        csvReader.Comma = i.Delimiter

        records, err := csvReader.ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read CSV: %w", err)
        }</span>

        <span class="cov8" title="1">if len(records) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("CSV file is empty")
        }</span>

        // Skip header if present
        <span class="cov8" title="1">startRow := 0
        if i.HasHeader </span><span class="cov8" title="1">{
                startRow = 1
        }</span>

        <span class="cov8" title="1">if len(records) &lt;= startRow </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("CSV file contains no data rows")
        }</span>

        // Auto-detect format if needed
        <span class="cov8" title="1">format := i.ColorFormat
        if format == FormatAuto </span><span class="cov8" title="1">{
                format = i.detectFormat(records[startRow])
        }</span>

        // Create palette
        <span class="cov8" title="1">p := palette.New("CSV Import")
        p.SetMetadata("format", "CSV")
        p.SetMetadata("color_format", format)

        // Parse colors
        for rowIndex := startRow; rowIndex &lt; len(records); rowIndex++ </span><span class="cov8" title="1">{
                record := records[rowIndex]
                if len(record) == 0 </span><span class="cov0" title="0">{
                        continue</span> // Skip empty rows
                }

                <span class="cov8" title="1">colorName, c, err := i.parseRow(record, format)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse row %d: %w", rowIndex+1, err)
                }</span>

                <span class="cov8" title="1">p.Add(c, colorName)</span>
        }

        <span class="cov8" title="1">return p, nil</span>
}

// CanImport returns true if this importer can handle the given format.
func (i *Importer) CanImport(format string) bool <span class="cov8" title="1">{
        return format == ".csv"
}</span>

// SupportedFormats returns the list of supported formats.
func (i *Importer) SupportedFormats() []string <span class="cov8" title="1">{
        return []string{".csv"}
}</span>

// detectFormat attempts to auto-detect the color format from a sample row.
func (i *Importer) detectFormat(record []string) ColorFormat <span class="cov8" title="1">{
        if len(record) == 0 </span><span class="cov0" title="0">{
                return FormatRGB // Default fallback
        }</span>

        // Check for hex color (single column with # prefix)
        <span class="cov8" title="1">if len(record) &gt;= 1 </span><span class="cov8" title="1">{
                if strings.HasPrefix(strings.TrimSpace(record[0]), "#") ||
                        strings.HasPrefix(strings.TrimSpace(record[len(record)-1]), "#") </span><span class="cov8" title="1">{
                        return FormatHex
                }</span>
        }

        // Count numeric columns
        <span class="cov8" title="1">numericCols := 0
        for _, field := range record </span><span class="cov8" title="1">{
                if _, err := strconv.ParseFloat(strings.TrimSpace(field), 64); err == nil </span><span class="cov8" title="1">{
                        numericCols++
                }</span>
        }

        // Determine format based on number of numeric columns
        <span class="cov8" title="1">switch numericCols </span>{
        case 3:<span class="cov8" title="1">
                return FormatRGB</span> // Could also be HSB or LAB, but RGB is most common
        case 4:<span class="cov8" title="1">
                return FormatCMYK</span>
        default:<span class="cov0" title="0">
                return FormatRGB</span> // Default fallback
        }
}

// parseRow parses a single CSV row into a color name and color.
func (i *Importer) parseRow(record []string, format ColorFormat) (string, color.Color, error) <span class="cov8" title="1">{
        if len(record) == 0 </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("empty row")
        }</span>

        // Try to find color name (usually first or last column that's not numeric)
        <span class="cov8" title="1">colorName := ""
        colorData := record

        // Check if first column is non-numeric (likely a name)
        if _, err := strconv.ParseFloat(strings.TrimSpace(record[0]), 64); err != nil </span><span class="cov8" title="1">{
                colorName = strings.TrimSpace(record[0])
                colorData = record[1:]
        }</span> else<span class="cov0" title="0"> if len(record) &gt; 3 </span><span class="cov0" title="0">{
                // Check if last column is non-numeric (name at end)
                if _, err := strconv.ParseFloat(strings.TrimSpace(record[len(record)-1]), 64); err != nil </span><span class="cov0" title="0">{
                        colorName = strings.TrimSpace(record[len(record)-1])
                        colorData = record[:len(record)-1]
                }</span>
        }

        // Parse color based on format
        <span class="cov8" title="1">c, err := i.parseColor(colorData, format)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, err
        }</span>

        <span class="cov8" title="1">if colorName == "" </span><span class="cov0" title="0">{
                colorName = c.String()
        }</span>

        <span class="cov8" title="1">return colorName, c, nil</span>
}

// parseColor parses color data from CSV fields.
func (i *Importer) parseColor(fields []string, format ColorFormat) (color.Color, error) <span class="cov8" title="1">{
        switch format </span>{
        case FormatHex:<span class="cov8" title="1">
                return i.parseHexColor(fields)</span>
        case FormatRGB:<span class="cov8" title="1">
                return i.parseRGBColor(fields, false)</span>
        case FormatRGBFloat:<span class="cov8" title="1">
                return i.parseRGBColor(fields, true)</span>
        case FormatCMYK:<span class="cov8" title="1">
                return i.parseCMYKColor(fields)</span>
        case FormatHSB:<span class="cov8" title="1">
                return i.parseHSBColor(fields)</span>
        case FormatLAB:<span class="cov8" title="1">
                return i.parseLABColor(fields)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported color format: %v", format)</span>
        }
}

// parseHexColor parses a hex color string.
func (i *Importer) parseHexColor(fields []string) (color.Color, error) <span class="cov8" title="1">{
        if len(fields) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no hex color data")
        }</span>

        // Find the hex color in the fields
        <span class="cov8" title="1">var hexStr string
        for _, field := range fields </span><span class="cov8" title="1">{
                field = strings.TrimSpace(field)
                if strings.HasPrefix(field, "#") </span><span class="cov8" title="1">{
                        hexStr = field
                        break</span>
                }
        }

        <span class="cov8" title="1">if hexStr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no hex color found")
        }</span>

        // Remove # prefix
        <span class="cov8" title="1">hexStr = strings.TrimPrefix(hexStr, "#")

        if len(hexStr) != 6 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid hex color format: %s", hexStr)
        }</span>

        // Parse RGB components
        <span class="cov8" title="1">r, err := strconv.ParseUint(hexStr[0:2], 16, 8)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid red component: %w", err)
        }</span>

        <span class="cov8" title="1">g, err := strconv.ParseUint(hexStr[2:4], 16, 8)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid green component: %w", err)
        }</span>

        <span class="cov8" title="1">b, err := strconv.ParseUint(hexStr[4:6], 16, 8)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid blue component: %w", err)
        }</span>

        <span class="cov8" title="1">return color.NewRGB(uint8(r), uint8(g), uint8(b)), nil</span>
}

// parseRGBColor parses RGB color components.
func (i *Importer) parseRGBColor(fields []string, isFloat bool) (color.Color, error) <span class="cov8" title="1">{
        if len(fields) &lt; 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient RGB data: need 3 values, got %d", len(fields))
        }</span>

        <span class="cov8" title="1">if isFloat </span><span class="cov8" title="1">{
                // Parse float values (0.0-1.0)
                r, err := strconv.ParseFloat(strings.TrimSpace(fields[0]), 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid red component: %w", err)
                }</span>

                <span class="cov8" title="1">g, err := strconv.ParseFloat(strings.TrimSpace(fields[1]), 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid green component: %w", err)
                }</span>

                <span class="cov8" title="1">b, err := strconv.ParseFloat(strings.TrimSpace(fields[2]), 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid blue component: %w", err)
                }</span>

                <span class="cov8" title="1">return color.NewRGBFromFloat(r, g, b), nil</span>
        } else<span class="cov8" title="1"> {
                // Parse integer values (0-255)
                r, err := strconv.ParseUint(strings.TrimSpace(fields[0]), 10, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid red component: %w", err)
                }</span>

                <span class="cov8" title="1">g, err := strconv.ParseUint(strings.TrimSpace(fields[1]), 10, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid green component: %w", err)
                }</span>

                <span class="cov8" title="1">b, err := strconv.ParseUint(strings.TrimSpace(fields[2]), 10, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid blue component: %w", err)
                }</span>

                <span class="cov8" title="1">return color.NewRGB(uint8(r), uint8(g), uint8(b)), nil</span>
        }
}

// parseCMYKColor parses CMYK color components.
func (i *Importer) parseCMYKColor(fields []string) (color.Color, error) <span class="cov8" title="1">{
        if len(fields) &lt; 4 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient CMYK data: need 4 values, got %d", len(fields))
        }</span>

        <span class="cov8" title="1">c, err := strconv.ParseUint(strings.TrimSpace(fields[0]), 10, 8)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid cyan component: %w", err)
        }</span>

        <span class="cov8" title="1">m, err := strconv.ParseUint(strings.TrimSpace(fields[1]), 10, 8)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid magenta component: %w", err)
        }</span>

        <span class="cov8" title="1">y, err := strconv.ParseUint(strings.TrimSpace(fields[2]), 10, 8)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid yellow component: %w", err)
        }</span>

        <span class="cov8" title="1">k, err := strconv.ParseUint(strings.TrimSpace(fields[3]), 10, 8)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid key component: %w", err)
        }</span>

        <span class="cov8" title="1">return color.NewCMYK(uint8(c), uint8(m), uint8(y), uint8(k)), nil</span>
}

// parseHSBColor parses HSB color components.
func (i *Importer) parseHSBColor(fields []string) (color.Color, error) <span class="cov8" title="1">{
        if len(fields) &lt; 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient HSB data: need 3 values, got %d", len(fields))
        }</span>

        <span class="cov8" title="1">h, err := strconv.ParseUint(strings.TrimSpace(fields[0]), 10, 16)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid hue component: %w", err)
        }</span>

        <span class="cov8" title="1">s, err := strconv.ParseUint(strings.TrimSpace(fields[1]), 10, 8)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid saturation component: %w", err)
        }</span>

        <span class="cov8" title="1">b, err := strconv.ParseUint(strings.TrimSpace(fields[2]), 10, 8)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid brightness component: %w", err)
        }</span>

        <span class="cov8" title="1">return color.NewHSB(uint16(h), uint8(s), uint8(b)), nil</span>
}

// parseLABColor parses LAB color components.
func (i *Importer) parseLABColor(fields []string) (color.Color, error) <span class="cov8" title="1">{
        if len(fields) &lt; 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient LAB data: need 3 values, got %d", len(fields))
        }</span>

        <span class="cov8" title="1">l, err := strconv.ParseInt(strings.TrimSpace(fields[0]), 10, 8)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid L component: %w", err)
        }</span>

        <span class="cov8" title="1">a, err := strconv.ParseInt(strings.TrimSpace(fields[1]), 10, 8)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid A component: %w", err)
        }</span>

        <span class="cov8" title="1">b, err := strconv.ParseInt(strings.TrimSpace(fields[2]), 10, 8)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid B component: %w", err)
        }</span>

        <span class="cov8" title="1">return color.NewLAB(int8(l), int8(a), int8(b)), nil</span>
}

// Exporter implements exporting palettes to CSV format.
type Exporter struct {
        // Delimiter specifies the field delimiter (default: comma)
        Delimiter rune
        // IncludeHeader indicates if column headers should be written
        IncludeHeader bool
        // ColorFormat specifies how colors should be formatted in the CSV
        ColorFormat ColorFormat
}

// NewExporter creates a new CSV exporter with default settings.
func NewExporter() *Exporter <span class="cov8" title="1">{
        return &amp;Exporter{
                Delimiter:     ',',
                IncludeHeader: true,
                ColorFormat:   FormatRGB,
        }
}</span>

// Export converts a palette to CSV format and writes it.
func (e *Exporter) Export(p *palette.Palette, w io.Writer) error <span class="cov8" title="1">{
        csvWriter := csv.NewWriter(w)
        csvWriter.Comma = e.Delimiter
        defer csvWriter.Flush()

        // Write header if requested
        if e.IncludeHeader </span><span class="cov8" title="1">{
                header := e.getHeader()
                if err := csvWriter.Write(header); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write header: %w", err)
                }</span>
        }

        // Write colors
        <span class="cov8" title="1">for i := range p.Len() </span><span class="cov8" title="1">{
                namedColor, err := p.Get(i)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get color at index %d: %w", i, err)
                }</span>

                <span class="cov8" title="1">record := e.formatColor(namedColor)
                if err := csvWriter.Write(record); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write color %s: %w", namedColor.Name, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// CanExport returns true if this exporter can handle the given format.
func (e *Exporter) CanExport(format string) bool <span class="cov8" title="1">{
        return format == ".csv"
}</span>

// SupportedFormats returns the list of supported formats.
func (e *Exporter) SupportedFormats() []string <span class="cov8" title="1">{
        return []string{".csv"}
}</span>

// getHeader returns the appropriate CSV header for the color format.
func (e *Exporter) getHeader() []string <span class="cov8" title="1">{
        switch e.ColorFormat </span>{
        case FormatHex:<span class="cov8" title="1">
                return []string{"Name", "Hex"}</span>
        case FormatRGB, FormatRGBFloat:<span class="cov8" title="1">
                return []string{"Name", "R", "G", "B"}</span>
        case FormatCMYK:<span class="cov8" title="1">
                return []string{"Name", "C", "M", "Y", "K"}</span>
        case FormatHSB:<span class="cov0" title="0">
                return []string{"Name", "H", "S", "B"}</span>
        case FormatLAB:<span class="cov0" title="0">
                return []string{"Name", "L", "A", "B"}</span>
        default:<span class="cov0" title="0">
                return []string{"Name", "R", "G", "B"}</span>
        }
}

// formatColor formats a named color according to the export format.
func (e *Exporter) formatColor(namedColor palette.NamedColor) []string <span class="cov8" title="1">{
        name := namedColor.Name
        if name == "" </span><span class="cov0" title="0">{
                name = namedColor.Color.String()
        }</span>

        <span class="cov8" title="1">switch e.ColorFormat </span>{
        case FormatHex:<span class="cov8" title="1">
                rgb := namedColor.Color.ToRGB()
                hex := fmt.Sprintf("#%02X%02X%02X", rgb.R, rgb.G, rgb.B)
                return []string{name, hex}</span>

        case FormatRGB:<span class="cov8" title="1">
                rgb := namedColor.Color.ToRGB()
                return []string{name, fmt.Sprintf("%d", rgb.R), fmt.Sprintf("%d", rgb.G), fmt.Sprintf("%d", rgb.B)}</span>

        case FormatRGBFloat:<span class="cov8" title="1">
                rgb := namedColor.Color.ToRGB()
                return []string{
                        name,
                        fmt.Sprintf("%.3f", float64(rgb.R)/255.0),
                        fmt.Sprintf("%.3f", float64(rgb.G)/255.0),
                        fmt.Sprintf("%.3f", float64(rgb.B)/255.0),
                }</span>

        case FormatCMYK:<span class="cov8" title="1">
                cmyk := namedColor.Color.ToCMYK()
                return []string{name, fmt.Sprintf("%d", cmyk.C), fmt.Sprintf("%d", cmyk.M), fmt.Sprintf("%d", cmyk.Y), fmt.Sprintf("%d", cmyk.K)}</span>

        case FormatHSB:<span class="cov0" title="0">
                hsb := namedColor.Color.ToHSB()
                return []string{name, fmt.Sprintf("%d", hsb.H), fmt.Sprintf("%d", hsb.S), fmt.Sprintf("%d", hsb.B)}</span>

        case FormatLAB:<span class="cov0" title="0">
                lab := namedColor.Color.ToLAB()
                return []string{name, fmt.Sprintf("%d", lab.L), fmt.Sprintf("%d", lab.A), fmt.Sprintf("%d", lab.B)}</span>

        default:<span class="cov0" title="0">
                rgb := namedColor.Color.ToRGB()
                return []string{name, fmt.Sprintf("%d", rgb.R), fmt.Sprintf("%d", rgb.G), fmt.Sprintf("%d", rgb.B)}</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package io

import (
        "fmt"
        "io"
        "path/filepath"
        "strings"

        "github.com/kennyp/palette/palette"
)

// Importer defines the interface for importing palettes from various formats.
type Importer interface {
        // Import reads a palette from the given reader.
        Import(r io.Reader) (*palette.Palette, error)

        // CanImport returns true if this importer can handle the given format.
        // The format parameter is typically a file extension or MIME type.
        CanImport(format string) bool

        // SupportedFormats returns a list of supported formats (extensions/MIME types).
        SupportedFormats() []string
}

// Exporter defines the interface for exporting palettes to various formats.
type Exporter interface {
        // Export writes a palette to the given writer.
        Export(p *palette.Palette, w io.Writer) error

        // CanExport returns true if this exporter can handle the given format.
        // The format parameter is typically a file extension or MIME type.
        CanExport(format string) bool

        // SupportedFormats returns a list of supported formats (extensions/MIME types).
        SupportedFormats() []string
}

// Registry manages importers and exporters for different formats.
type Registry struct {
        importers []Importer
        exporters []Exporter
}

// NewRegistry creates a new empty registry.
func NewRegistry() *Registry <span class="cov8" title="1">{
        return &amp;Registry{
                importers: make([]Importer, 0),
                exporters: make([]Exporter, 0),
        }
}</span>

// RegisterImporter adds an importer to the registry.
func (r *Registry) RegisterImporter(importer Importer) <span class="cov8" title="1">{
        r.importers = append(r.importers, importer)
}</span>

// RegisterExporter adds an exporter to the registry.
func (r *Registry) RegisterExporter(exporter Exporter) <span class="cov8" title="1">{
        r.exporters = append(r.exporters, exporter)
}</span>

// FindImporter finds an importer that can handle the given format.
func (r *Registry) FindImporter(format string) (Importer, error) <span class="cov8" title="1">{
        normalizedFormat := normalizeFormat(format)

        for _, importer := range r.importers </span><span class="cov8" title="1">{
                if importer.CanImport(normalizedFormat) </span><span class="cov8" title="1">{
                        return importer, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("no importer found for format: %s", format)</span>
}

// FindExporter finds an exporter that can handle the given format.
func (r *Registry) FindExporter(format string) (Exporter, error) <span class="cov8" title="1">{
        normalizedFormat := normalizeFormat(format)

        for _, exporter := range r.exporters </span><span class="cov8" title="1">{
                if exporter.CanExport(normalizedFormat) </span><span class="cov8" title="1">{
                        return exporter, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("no exporter found for format: %s", format)</span>
}

// Import imports a palette using the appropriate importer for the given format.
func (r *Registry) Import(reader io.Reader, format string) (*palette.Palette, error) <span class="cov8" title="1">{
        importer, err := r.FindImporter(format)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return importer.Import(reader)</span>
}

// Export exports a palette using the appropriate exporter for the given format.
func (r *Registry) Export(p *palette.Palette, writer io.Writer, format string) error <span class="cov8" title="1">{
        exporter, err := r.FindExporter(format)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return exporter.Export(p, writer)</span>
}

// ImportFromFile imports a palette from a file, detecting the format from the file extension.
func (r *Registry) ImportFromFile(filename string, reader io.Reader) (*palette.Palette, error) <span class="cov8" title="1">{
        ext := filepath.Ext(filename)
        if ext == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("cannot determine format from filename: %s", filename)
        }</span>

        <span class="cov8" title="1">return r.Import(reader, ext)</span>
}

// ExportToFile exports a palette to a file, detecting the format from the file extension.
func (r *Registry) ExportToFile(p *palette.Palette, filename string, writer io.Writer) error <span class="cov8" title="1">{
        ext := filepath.Ext(filename)
        if ext == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot determine format from filename: %s", filename)
        }</span>

        <span class="cov8" title="1">return r.Export(p, writer, ext)</span>
}

// ListSupportedImportFormats returns a list of all supported import formats.
func (r *Registry) ListSupportedImportFormats() []string <span class="cov8" title="1">{
        var formats []string
        seen := make(map[string]bool)

        for _, importer := range r.importers </span><span class="cov8" title="1">{
                for _, format := range importer.SupportedFormats() </span><span class="cov8" title="1">{
                        normalized := normalizeFormat(format)
                        if !seen[normalized] </span><span class="cov8" title="1">{
                                formats = append(formats, normalized)
                                seen[normalized] = true
                        }</span>
                }
        }

        <span class="cov8" title="1">return formats</span>
}

// ListSupportedExportFormats returns a list of all supported export formats.
func (r *Registry) ListSupportedExportFormats() []string <span class="cov8" title="1">{
        var formats []string
        seen := make(map[string]bool)

        for _, exporter := range r.exporters </span><span class="cov8" title="1">{
                for _, format := range exporter.SupportedFormats() </span><span class="cov8" title="1">{
                        normalized := normalizeFormat(format)
                        if !seen[normalized] </span><span class="cov8" title="1">{
                                formats = append(formats, normalized)
                                seen[normalized] = true
                        }</span>
                }
        }

        <span class="cov8" title="1">return formats</span>
}

// AutoDetectFormat attempts to detect the format from the content.
// This is a basic implementation that can be extended with magic number detection.
func (r *Registry) AutoDetectFormat(reader io.Reader) (string, error) <span class="cov8" title="1">{
        // Read the first few bytes to detect magic numbers
        buffer := make([]byte, 16)
        n, err := reader.Read(buffer)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read header: %w", err)
        }</span>

        <span class="cov8" title="1">if n &lt; 4 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("insufficient data to detect format")
        }</span>

        // Check for known magic numbers
        <span class="cov8" title="1">header := string(buffer[:4])
        switch header </span>{
        case "8BCB":<span class="cov8" title="1"> // Adobe Color Book
                return ".acb", nil</span>
        default:<span class="cov8" title="1">
                // Check for JSON (starts with '{' or '[')
                if buffer[0] == '{' || buffer[0] == '[' </span><span class="cov8" title="1">{
                        return ".json", nil
                }</span>

                // Check for CSV (first line might contain commas)
                <span class="cov8" title="1">firstLine := strings.Split(string(buffer[:n]), "\n")[0]
                if strings.Contains(firstLine, ",") </span><span class="cov8" title="1">{
                        return ".csv", nil
                }</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("unable to detect format from content")</span>
}

// DefaultRegistry returns a registry with all built-in importers and exporters registered.
var DefaultRegistry = NewRegistry()

// Convenience functions that use the default registry

// Import imports a palette using the default registry.
func Import(reader io.Reader, format string) (*palette.Palette, error) <span class="cov8" title="1">{
        return DefaultRegistry.Import(reader, format)
}</span>

// Export exports a palette using the default registry.
func Export(p *palette.Palette, writer io.Writer, format string) error <span class="cov8" title="1">{
        return DefaultRegistry.Export(p, writer, format)
}</span>

// ImportFromFile imports a palette from a file using the default registry.
func ImportFromFile(filename string, reader io.Reader) (*palette.Palette, error) <span class="cov8" title="1">{
        return DefaultRegistry.ImportFromFile(filename, reader)
}</span>

// ExportToFile exports a palette to a file using the default registry.
func ExportToFile(p *palette.Palette, filename string, writer io.Writer) error <span class="cov8" title="1">{
        return DefaultRegistry.ExportToFile(p, filename, writer)
}</span>

// Helper functions

// normalizeFormat normalizes a format string (file extension or MIME type).
func normalizeFormat(format string) string <span class="cov8" title="1">{
        format = strings.ToLower(strings.TrimSpace(format))

        // Handle file extensions
        if strings.HasPrefix(format, ".") </span><span class="cov8" title="1">{
                return format
        }</span>

        // Handle common extensions without dot
        <span class="cov8" title="1">switch format </span>{
        case "acb", "colorbook":<span class="cov8" title="1">
                return ".acb"</span>
        case "aco", "colorswatch", "swatch":<span class="cov8" title="1">
                return ".aco"</span>
        case "csv":<span class="cov8" title="1">
                return ".csv"</span>
        case "json":<span class="cov8" title="1">
                return ".json"</span>
        }

        // Handle MIME types
        <span class="cov8" title="1">switch format </span>{
        case "application/json":<span class="cov8" title="1">
                return ".json"</span>
        case "text/csv":<span class="cov8" title="1">
                return ".csv"</span>
        }

        // Return as-is if we don't recognize it
        <span class="cov8" title="1">return format</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package json

import (
        "encoding/json"
        "fmt"
        "io"

        "github.com/kennyp/palette/color"
        "github.com/kennyp/palette/palette"
)

// Importer implements importing JSON files containing palette data.
type Importer struct {
        // StrictMode determines if unknown fields should cause an error
        StrictMode bool
}

// NewImporter creates a new JSON importer.
func NewImporter() *Importer <span class="cov8" title="1">{
        return &amp;Importer{
                StrictMode: false,
        }
}</span>

// Import reads a JSON file and converts it to a palette.
func (i *Importer) Import(r io.Reader) (*palette.Palette, error) <span class="cov8" title="1">{
        data, err := io.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read JSON data: %w", err)
        }</span>

        // Try to parse as our standard palette format first
        <span class="cov8" title="1">var paletteData PaletteJSON
        if err := json.Unmarshal(data, &amp;paletteData); err == nil &amp;&amp; paletteData.Name != "" </span><span class="cov8" title="1">{
                return i.convertFromPaletteJSON(paletteData)
        }</span>

        // Try to parse as array of colors
        <span class="cov8" title="1">var colorsArray []ColorJSON
        if err := json.Unmarshal(data, &amp;colorsArray); err == nil &amp;&amp; len(colorsArray) &gt; 0 </span><span class="cov8" title="1">{
                return i.convertFromColorArray(colorsArray)
        }</span>

        // Try to parse as generic color object
        <span class="cov8" title="1">var colorObj map[string]any
        if err := json.Unmarshal(data, &amp;colorObj); err == nil </span><span class="cov8" title="1">{
                return i.convertFromGenericJSON(colorObj)
        }</span>

        <span class="cov8" title="1">return nil, fmt.Errorf("unable to parse JSON as palette data")</span>
}

// CanImport returns true if this importer can handle the given format.
func (i *Importer) CanImport(format string) bool <span class="cov8" title="1">{
        return format == ".json"
}</span>

// SupportedFormats returns the list of supported formats.
func (i *Importer) SupportedFormats() []string <span class="cov8" title="1">{
        return []string{".json"}
}</span>

// PaletteJSON represents the JSON structure for a complete palette.
type PaletteJSON struct {
        Name        string      `json:"name"`
        Description string      `json:"description,omitempty"`
        Colors      []ColorJSON `json:"colors"`
        Metadata    any `json:"metadata,omitempty"`
}

// ColorJSON represents the JSON structure for a color.
type ColorJSON struct {
        Name       string                 `json:"name,omitempty"`
        ColorSpace string                 `json:"color_space,omitempty"`
        RGB        *RGBValues             `json:"rgb,omitempty"`
        CMYK       *CMYKValues            `json:"cmyk,omitempty"`
        HSB        *HSBValues             `json:"hsb,omitempty"`
        LAB        *LABValues             `json:"lab,omitempty"`
        Hex        string                 `json:"hex,omitempty"`
        Values     any            `json:"values,omitempty"`
        Metadata   map[string]any `json:"metadata,omitempty"`
}

// RGBValues represents RGB color values.
type RGBValues struct {
        R uint8 `json:"r"`
        G uint8 `json:"g"`
        B uint8 `json:"b"`
}

// CMYKValues represents CMYK color values.
type CMYKValues struct {
        C uint8 `json:"c"`
        M uint8 `json:"m"`
        Y uint8 `json:"y"`
        K uint8 `json:"k"`
}

// HSBValues represents HSB color values.
type HSBValues struct {
        H uint16 `json:"h"`
        S uint8  `json:"s"`
        B uint8  `json:"b"`
}

// LABValues represents LAB color values.
type LABValues struct {
        L int8 `json:"l"`
        A int8 `json:"a"`
        B int8 `json:"b"`
}

// convertFromPaletteJSON converts a PaletteJSON to a palette.
func (i *Importer) convertFromPaletteJSON(data PaletteJSON) (*palette.Palette, error) <span class="cov8" title="1">{
        p := palette.New(data.Name)
        p.Description = data.Description

        // Set metadata
        p.SetMetadata("format", "JSON")
        if data.Metadata != nil </span><span class="cov8" title="1">{
                p.SetMetadata("original_metadata", data.Metadata)
        }</span>

        // Convert colors
        <span class="cov8" title="1">for idx, colorData := range data.Colors </span><span class="cov8" title="1">{
                c, err := i.convertColorJSON(colorData)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to convert color at index %d: %w", idx, err)
                }</span>

                <span class="cov8" title="1">colorName := colorData.Name
                if colorName == "" </span><span class="cov0" title="0">{
                        colorName = fmt.Sprintf("Color %d", idx+1)
                }</span>

                <span class="cov8" title="1">p.Add(c, colorName)</span>
        }

        <span class="cov8" title="1">return p, nil</span>
}

// convertFromColorArray converts an array of ColorJSON to a palette.
func (i *Importer) convertFromColorArray(colors []ColorJSON) (*palette.Palette, error) <span class="cov8" title="1">{
        p := palette.New("JSON Color Array")
        p.SetMetadata("format", "JSON")

        for idx, colorData := range colors </span><span class="cov8" title="1">{
                c, err := i.convertColorJSON(colorData)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to convert color at index %d: %w", idx, err)
                }</span>

                <span class="cov8" title="1">colorName := colorData.Name
                if colorName == "" </span><span class="cov0" title="0">{
                        colorName = fmt.Sprintf("Color %d", idx+1)
                }</span>

                <span class="cov8" title="1">p.Add(c, colorName)</span>
        }

        <span class="cov8" title="1">return p, nil</span>
}

// convertFromGenericJSON attempts to parse generic JSON color data.
func (i *Importer) convertFromGenericJSON(data map[string]any) (*palette.Palette, error) <span class="cov8" title="1">{
        p := palette.New("JSON Import")
        p.SetMetadata("format", "JSON")

        // Look for known color fields
        colorCount := 0

        for key, value := range data </span><span class="cov8" title="1">{
                if c := i.tryParseColorValue(key, value); c != nil </span><span class="cov8" title="1">{
                        p.Add(c, key)
                        colorCount++
                }</span>
        }

        <span class="cov8" title="1">if colorCount == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no recognizable color data found in JSON")
        }</span>

        <span class="cov8" title="1">return p, nil</span>
}

// convertColorJSON converts a ColorJSON to a color.Color.
func (i *Importer) convertColorJSON(data ColorJSON) (color.Color, error) <span class="cov8" title="1">{
        // Try each color space in order of preference
        if data.RGB != nil </span><span class="cov8" title="1">{
                return color.NewRGB(data.RGB.R, data.RGB.G, data.RGB.B), nil
        }</span>

        <span class="cov8" title="1">if data.Hex != "" </span><span class="cov8" title="1">{
                return i.parseHexColor(data.Hex)
        }</span>

        <span class="cov8" title="1">if data.CMYK != nil </span><span class="cov8" title="1">{
                return color.NewCMYK(data.CMYK.C, data.CMYK.M, data.CMYK.Y, data.CMYK.K), nil
        }</span>

        <span class="cov8" title="1">if data.HSB != nil </span><span class="cov0" title="0">{
                return color.NewHSB(data.HSB.H, data.HSB.S, data.HSB.B), nil
        }</span>

        <span class="cov8" title="1">if data.LAB != nil </span><span class="cov0" title="0">{
                return color.NewLAB(data.LAB.L, data.LAB.A, data.LAB.B), nil
        }</span>

        // Try to parse from generic values field
        <span class="cov8" title="1">if data.Values != nil </span><span class="cov0" title="0">{
                return i.parseGenericValues(data.Values, data.ColorSpace)
        }</span>

        <span class="cov8" title="1">return nil, fmt.Errorf("no valid color data found")</span>
}

// parseHexColor parses a hex color string.
func (i *Importer) parseHexColor(hex string) (color.Color, error) <span class="cov8" title="1">{
        if len(hex) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty hex color")
        }</span>

        // Remove # prefix if present
        <span class="cov8" title="1">if hex[0] == '#' </span><span class="cov8" title="1">{
                hex = hex[1:]
        }</span>

        <span class="cov8" title="1">if len(hex) != 6 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid hex color length: %d", len(hex))
        }</span>

        <span class="cov8" title="1">var r, g, b uint8
        if _, err := fmt.Sscanf(hex, "%02x%02x%02x", &amp;r, &amp;g, &amp;b); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse hex color: %w", err)
        }</span>

        <span class="cov8" title="1">return color.NewRGB(r, g, b), nil</span>
}

// parseGenericValues parses generic color values based on color space.
func (i *Importer) parseGenericValues(values any, colorSpace string) (color.Color, error) <span class="cov8" title="1">{
        // Try to convert to float64 slice
        var nums []float64

        switch v := values.(type) </span>{
        case []any:<span class="cov8" title="1">
                nums = make([]float64, len(v))
                for i, val := range v </span><span class="cov8" title="1">{
                        if f, ok := val.(float64); ok </span><span class="cov8" title="1">{
                                nums[i] = f
                        }</span> else<span class="cov8" title="1"> {
                                return nil, fmt.Errorf("non-numeric value in color array")
                        }</span>
                }
        case []float64:<span class="cov0" title="0">
                nums = v</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported values format")</span>
        }

        // Parse based on color space and number of values
        <span class="cov8" title="1">switch colorSpace </span>{
        case "RGB", "rgb":<span class="cov8" title="1">
                if len(nums) &lt; 3 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("insufficient RGB values")
                }</span>
                <span class="cov8" title="1">return color.NewRGB(uint8(nums[0]), uint8(nums[1]), uint8(nums[2])), nil</span>

        case "CMYK", "cmyk":<span class="cov8" title="1">
                if len(nums) &lt; 4 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("insufficient CMYK values")
                }</span>
                <span class="cov8" title="1">return color.NewCMYK(uint8(nums[0]), uint8(nums[1]), uint8(nums[2]), uint8(nums[3])), nil</span>

        case "HSB", "hsb", "HSV", "hsv":<span class="cov8" title="1">
                if len(nums) &lt; 3 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("insufficient HSB values")
                }</span>
                <span class="cov8" title="1">return color.NewHSB(uint16(nums[0]), uint8(nums[1]), uint8(nums[2])), nil</span>

        case "LAB", "lab":<span class="cov8" title="1">
                if len(nums) &lt; 3 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("insufficient LAB values")
                }</span>
                <span class="cov8" title="1">return color.NewLAB(int8(nums[0]), int8(nums[1]), int8(nums[2])), nil</span>

        default:<span class="cov8" title="1">
                // Default to RGB if no color space specified
                if len(nums) &gt;= 3 </span><span class="cov8" title="1">{
                        return color.NewRGB(uint8(nums[0]), uint8(nums[1]), uint8(nums[2])), nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("unable to parse color values")</span>
}

// tryParseColorValue attempts to parse a value as a color.
func (i *Importer) tryParseColorValue(key string, value any) color.Color <span class="cov8" title="1">{
        // Try hex string
        if str, ok := value.(string); ok </span><span class="cov8" title="1">{
                if c, err := i.parseHexColor(str); err == nil </span><span class="cov8" title="1">{
                        return c
                }</span>
        }

        // Try array of numbers
        <span class="cov8" title="1">if arr, ok := value.([]any); ok &amp;&amp; len(arr) &gt;= 3 </span><span class="cov8" title="1">{
                var nums []float64
                for _, v := range arr </span><span class="cov8" title="1">{
                        if f, ok := v.(float64); ok </span><span class="cov8" title="1">{
                                nums = append(nums, f)
                        }</span> else<span class="cov0" title="0"> {
                                return nil
                        }</span>
                }

                <span class="cov8" title="1">if len(nums) &gt;= 3 </span><span class="cov8" title="1">{
                        return color.NewRGB(uint8(nums[0]), uint8(nums[1]), uint8(nums[2]))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Exporter implements exporting palettes to JSON format.
type Exporter struct {
        // PrettyPrint determines if the JSON should be formatted with indentation
        PrettyPrint bool
        // IncludeMetadata determines if palette metadata should be included
        IncludeMetadata bool
        // ColorFormat specifies which color representations to include
        ColorFormat ColorFormatFlags
}

// ColorFormatFlags represents which color formats to include in the JSON.
type ColorFormatFlags int

const (
        // FormatPrimary includes only the primary color space for each color
        FormatPrimary ColorFormatFlags = 1 &lt;&lt; iota
        // FormatRGB includes RGB values
        FormatRGB
        // FormatHex includes hex representation
        FormatHex
        // FormatCMYK includes CMYK values
        FormatCMYK
        // FormatHSB includes HSB values
        FormatHSB
        // FormatLAB includes LAB values
        FormatLAB
        // FormatAll includes all color representations
        FormatAll = FormatRGB | FormatHex | FormatCMYK | FormatHSB | FormatLAB
)

// NewExporter creates a new JSON exporter with default settings.
func NewExporter() *Exporter <span class="cov8" title="1">{
        return &amp;Exporter{
                PrettyPrint:     true,
                IncludeMetadata: true,
                ColorFormat:     FormatRGB | FormatHex,
        }
}</span>

// Export converts a palette to JSON format and writes it.
func (e *Exporter) Export(p *palette.Palette, w io.Writer) error <span class="cov8" title="1">{
        paletteData := PaletteJSON{
                Name:        p.Name,
                Description: p.Description,
                Colors:      make([]ColorJSON, 0, p.Len()),
        }

        // Include metadata if requested
        if e.IncludeMetadata </span><span class="cov8" title="1">{
                metadata := make(map[string]any)
                for _, key := range p.ListMetadataKeys() </span><span class="cov8" title="1">{
                        if value, ok := p.GetMetadata(key); ok </span><span class="cov8" title="1">{
                                metadata[key] = value
                        }</span>
                }
                <span class="cov8" title="1">if len(metadata) &gt; 0 </span><span class="cov8" title="1">{
                        paletteData.Metadata = metadata
                }</span>
        }

        // Convert colors
        <span class="cov8" title="1">for i := range p.Len() </span><span class="cov8" title="1">{
                namedColor, err := p.Get(i)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get color at index %d: %w", i, err)
                }</span>

                <span class="cov8" title="1">colorJSON := e.convertColorToJSON(namedColor)
                paletteData.Colors = append(paletteData.Colors, colorJSON)</span>
        }

        // Marshal JSON
        <span class="cov8" title="1">var data []byte
        var err error

        if e.PrettyPrint </span><span class="cov8" title="1">{
                data, err = json.MarshalIndent(paletteData, "", "  ")
        }</span> else<span class="cov8" title="1"> {
                data, err = json.Marshal(paletteData)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal JSON: %w", err)
        }</span>

        // Write to output
        <span class="cov8" title="1">_, err = w.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write JSON data: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CanExport returns true if this exporter can handle the given format.
func (e *Exporter) CanExport(format string) bool <span class="cov8" title="1">{
        return format == ".json"
}</span>

// SupportedFormats returns the list of supported formats.
func (e *Exporter) SupportedFormats() []string <span class="cov8" title="1">{
        return []string{".json"}
}</span>

// convertColorToJSON converts a named color to JSON representation.
func (e *Exporter) convertColorToJSON(namedColor palette.NamedColor) ColorJSON <span class="cov8" title="1">{
        colorJSON := ColorJSON{
                Name:       namedColor.Name,
                ColorSpace: namedColor.Color.ColorSpace(),
        }

        // Include requested color formats
        if e.ColorFormat&amp;FormatRGB != 0 || e.ColorFormat&amp;FormatPrimary != 0 </span><span class="cov8" title="1">{
                rgb := namedColor.Color.ToRGB()
                colorJSON.RGB = &amp;RGBValues{R: rgb.R, G: rgb.G, B: rgb.B}
        }</span>

        <span class="cov8" title="1">if e.ColorFormat&amp;FormatHex != 0 </span><span class="cov8" title="1">{
                rgb := namedColor.Color.ToRGB()
                colorJSON.Hex = fmt.Sprintf("#%02X%02X%02X", rgb.R, rgb.G, rgb.B)
        }</span>

        <span class="cov8" title="1">if e.ColorFormat&amp;FormatCMYK != 0 </span><span class="cov8" title="1">{
                cmyk := namedColor.Color.ToCMYK()
                colorJSON.CMYK = &amp;CMYKValues{C: cmyk.C, M: cmyk.M, Y: cmyk.Y, K: cmyk.K}
        }</span>

        <span class="cov8" title="1">if e.ColorFormat&amp;FormatHSB != 0 </span><span class="cov8" title="1">{
                hsb := namedColor.Color.ToHSB()
                colorJSON.HSB = &amp;HSBValues{H: hsb.H, S: hsb.S, B: hsb.B}
        }</span>

        <span class="cov8" title="1">if e.ColorFormat&amp;FormatLAB != 0 </span><span class="cov8" title="1">{
                lab := namedColor.Color.ToLAB()
                colorJSON.LAB = &amp;LABValues{L: lab.L, A: lab.A, B: lab.B}
        }</span>

        <span class="cov8" title="1">return colorJSON</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package palette

import (
        "fmt"
        "maps"
        "slices"
        "strings"

        "github.com/kennyp/palette/color"
)

// Palette represents a collection of colors with metadata.
type Palette struct {
        Name        string       `json:"name"`
        Description string       `json:"description,omitempty"`
        Colors      []NamedColor `json:"colors"`
        metadata    map[string]any
}

// NamedColor represents a color with an optional name.
type NamedColor struct {
        Name  string      `json:"name,omitempty"`
        Color color.Color `json:"color"`
}

// New creates a new empty palette with the given name.
func New(name string) *Palette <span class="cov8" title="1">{
        return &amp;Palette{
                Name:     name,
                Colors:   make([]NamedColor, 0),
                metadata: make(map[string]any),
        }
}</span>

// NewWithColors creates a new palette with the given name and colors.
func NewWithColors(name string, colors ...NamedColor) *Palette <span class="cov8" title="1">{
        p := New(name)
        p.Colors = append(p.Colors, colors...)
        return p
}</span>

// Add adds a color to the palette.
func (p *Palette) Add(color color.Color, name string) <span class="cov8" title="1">{
        p.Colors = append(p.Colors, NamedColor{
                Name:  name,
                Color: color,
        })
}</span>

// AddColor adds a color to the palette without a name.
func (p *Palette) AddColor(color color.Color) <span class="cov8" title="1">{
        p.Colors = append(p.Colors, NamedColor{
                Color: color,
        })
}</span>

// Remove removes the color at the given index.
func (p *Palette) Remove(index int) error <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(p.Colors) </span><span class="cov8" title="1">{
                return fmt.Errorf("index %d out of range [0, %d)", index, len(p.Colors))
        }</span>

        <span class="cov8" title="1">p.Colors = slices.Delete(p.Colors, index, index+1)
        return nil</span>
}

// RemoveByName removes the first color with the given name.
func (p *Palette) RemoveByName(name string) bool <span class="cov8" title="1">{
        for i, c := range p.Colors </span><span class="cov8" title="1">{
                if c.Name == name </span><span class="cov8" title="1">{
                        p.Colors = slices.Delete(p.Colors, i, i+1)
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Get returns the color at the given index.
func (p *Palette) Get(index int) (NamedColor, error) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(p.Colors) </span><span class="cov8" title="1">{
                return NamedColor{}, fmt.Errorf("index %d out of range [0, %d)", index, len(p.Colors))
        }</span>
        <span class="cov8" title="1">return p.Colors[index], nil</span>
}

// GetByName returns the first color with the given name.
func (p *Palette) GetByName(name string) (NamedColor, bool) <span class="cov8" title="1">{
        for _, c := range p.Colors </span><span class="cov8" title="1">{
                if c.Name == name </span><span class="cov8" title="1">{
                        return c, true
                }</span>
        }
        <span class="cov8" title="1">return NamedColor{}, false</span>
}

// Len returns the number of colors in the palette.
func (p *Palette) Len() int <span class="cov8" title="1">{
        return len(p.Colors)
}</span>

// IsEmpty returns true if the palette has no colors.
func (p *Palette) IsEmpty() bool <span class="cov8" title="1">{
        return len(p.Colors) == 0
}</span>

// Clear removes all colors from the palette.
func (p *Palette) Clear() <span class="cov8" title="1">{
        p.Colors = p.Colors[:0]
}</span>

// Clone creates a deep copy of the palette.
func (p *Palette) Clone() *Palette <span class="cov8" title="1">{
        clone := &amp;Palette{
                Name:        p.Name,
                Description: p.Description,
                Colors:      make([]NamedColor, len(p.Colors)),
                metadata:    make(map[string]any),
        }

        copy(clone.Colors, p.Colors)

        // Copy metadata
        maps.Copy(clone.metadata, p.metadata)

        return clone
}</span>

// Filter returns a new palette containing only colors that match the predicate.
func (p *Palette) Filter(predicate func(NamedColor) bool) *Palette <span class="cov8" title="1">{
        filtered := New(p.Name + " (filtered)")
        filtered.Description = p.Description

        for _, c := range p.Colors </span><span class="cov8" title="1">{
                if predicate(c) </span><span class="cov8" title="1">{
                        filtered.Colors = append(filtered.Colors, c)
                }</span>
        }

        <span class="cov8" title="1">return filtered</span>
}

// FilterByColorSpace returns a new palette containing only colors in the given color space.
func (p *Palette) FilterByColorSpace(colorSpace string) *Palette <span class="cov8" title="1">{
        return p.Filter(func(c NamedColor) bool </span><span class="cov8" title="1">{
                return c.Color.ColorSpace() == colorSpace
        }</span>)
}

// Map applies a function to each color and returns a new palette.
func (p *Palette) Map(mapper func(NamedColor) NamedColor) *Palette <span class="cov8" title="1">{
        mapped := New(p.Name + " (mapped)")
        mapped.Description = p.Description
        mapped.Colors = make([]NamedColor, len(p.Colors))

        for i, c := range p.Colors </span><span class="cov8" title="1">{
                mapped.Colors[i] = mapper(c)
        }</span>

        <span class="cov8" title="1">return mapped</span>
}

// ConvertToColorSpace returns a new palette with all colors converted to the specified color space.
func (p *Palette) ConvertToColorSpace(colorSpace string) (*Palette, error) <span class="cov8" title="1">{
        return p.Map(func(c NamedColor) NamedColor </span><span class="cov8" title="1">{
                var convertedColor color.Color

                switch strings.ToUpper(colorSpace) </span>{
                case "RGB":<span class="cov0" title="0">
                        convertedColor = c.Color.ToRGB()</span>
                case "CMYK":<span class="cov8" title="1">
                        convertedColor = c.Color.ToCMYK()</span>
                case "LAB":<span class="cov0" title="0">
                        convertedColor = c.Color.ToLAB()</span>
                case "HSB":<span class="cov0" title="0">
                        convertedColor = c.Color.ToHSB()</span>
                default:<span class="cov8" title="1">
                        convertedColor = c.Color</span> // Keep original if unknown color space
                }

                <span class="cov8" title="1">return NamedColor{
                        Name:  c.Name,
                        Color: convertedColor,
                }</span>
        }), nil
}

// String returns a string representation of the palette.
func (p *Palette) String() string <span class="cov8" title="1">{
        var sb strings.Builder
        sb.WriteString(fmt.Sprintf("Palette: %s (%d colors)\n", p.Name, len(p.Colors)))

        if p.Description != "" </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("Description: %s\n", p.Description))
        }</span>

        <span class="cov8" title="1">for i, c := range p.Colors </span><span class="cov8" title="1">{
                if c.Name != "" </span><span class="cov8" title="1">{
                        sb.WriteString(fmt.Sprintf("  [%d] %s: %s\n", i, c.Name, c.Color.String()))
                }</span> else<span class="cov0" title="0"> {
                        sb.WriteString(fmt.Sprintf("  [%d] %s\n", i, c.Color.String()))
                }</span>
        }

        <span class="cov8" title="1">return sb.String()</span>
}

// SetMetadata sets a metadata value for the palette.
func (p *Palette) SetMetadata(key string, value any) <span class="cov8" title="1">{
        if p.metadata == nil </span><span class="cov0" title="0">{
                p.metadata = make(map[string]any)
        }</span>
        <span class="cov8" title="1">p.metadata[key] = value</span>
}

// GetMetadata gets a metadata value from the palette.
func (p *Palette) GetMetadata(key string) (any, bool) <span class="cov8" title="1">{
        if p.metadata == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov8" title="1">value, exists := p.metadata[key]
        return value, exists</span>
}

// RemoveMetadata removes a metadata key from the palette.
func (p *Palette) RemoveMetadata(key string) <span class="cov8" title="1">{
        if p.metadata != nil </span><span class="cov8" title="1">{
                delete(p.metadata, key)
        }</span>
}

// ListMetadataKeys returns all metadata keys.
func (p *Palette) ListMetadataKeys() []string <span class="cov8" title="1">{
        if p.metadata == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">keys := make([]string, 0, len(p.metadata))
        for k := range p.metadata </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">slices.Sort(keys)
        return keys</span>
}

// Validate checks if the palette is valid.
func (p *Palette) Validate() error <span class="cov8" title="1">{
        if p.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("palette name cannot be empty")
        }</span>

        // Check for duplicate named colors
        <span class="cov8" title="1">nameCount := make(map[string]int)
        for _, c := range p.Colors </span><span class="cov8" title="1">{
                if c.Name != "" </span><span class="cov8" title="1">{
                        nameCount[c.Name]++
                        if nameCount[c.Name] &gt; 1 </span><span class="cov8" title="1">{
                                return fmt.Errorf("duplicate color name: %s", c.Name)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
